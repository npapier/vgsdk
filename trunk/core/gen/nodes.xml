<?xml version="1.0"?>

<!--	VGSDK - Copyright (C) 2008, 2009, 2010, Nicolas Papier.
	Distributed under the terms of the GNU Library General Public License (LGPL)
	as published by the Free Software Foundation.
	Author Nicolas Papier -->

<nodes>

	<node	name = "Camera"
			inherits="GeometricalTransformation ProjectionTransformation">
		<doxygen>
			<docBrief>Camera node used to set the projection matrix, viewport and scissor box. Camera position and orientation could be specified too.</docBrief>
			<doc>Sets up the projection with an user defined matrix for the viewing frustum (into the world coordinate system). </doc>
			<doc>Sets up the camera position and orientation with 4x4 matrix from lookAt field.</doc>
			<doc>Note that some matrices (such as singular ones) may result in errors in bounding boxes, picking, and lighting. </doc>
			<ingroup>g_nodes</ingroup>
			<ingroup>g_singleAttributeNodes</ingroup>
			<ingroup>g_transformationNodes</ingroup>
		</doxygen>
		<!-- projection and lookAt renames into intrinsics and extrinsics -->
		<sf name="projection" doc="Determines the projection matrix.">
			<type name="MatrixR" namespace="vgm" default="vgm::MatrixR::getIdentity()"></type>
		</sf>
		<sf name="lookAt"
			doc="Determines the 3D geometric transformation as a 4x4 matrix applied to camera.\nNote that this transformation is applied to engine like any GeometricalTransformation node with composeTransformation field sets to false.\nBy default, the camera is situated at the origin, points down the negative z-axis, and has an up-vector of (0, 1, 0).">
			<type name="MatrixR" namespace="vgm" default="vgm::MatrixR::getIdentity()"></type>
		</sf>
		<of name="viewport" doc="Determines the viewport.">
			<type name="Rectangle2i" namespace="vgm" default="0, 0, 1600, 1200"/>
		</of>
		<of name="scissor" doc="Determines the scissor box. It is automatically enabled if this field is defined, otherwise it is disabled. The default value is empty, i.e. scissor test is disabled.">
			<type name="Rectangle2i" namespace="vgm" default=""/>
		</of>
		<includehpp>vgd/include/vgd/node/Camera.hpp</includehpp>
		<includecpp>vgd/src/node/Camera.cpp</includecpp>
	</node>


	<node name = "ClipPlane" inherits = "MultiAttribute" >
		<doxygen>
			<docBrief>Clipping plane node</docBrief>
			<doc>All subsequent shapes in the scene graph will be clipped to the half-space defined by the \c plane field.</doc>
			<doc>The half-space is the side of the plane in the direction of the plane normal.</doc>
			<doc>Any number of clipping planes may be active simultaneously, although the graphics library may place a limit on this number during rendering (i.e. 6 for OpenGL).</doc>
			<ingroup>g_nodes</ingroup>
			<ingroup>g_multiAttributeNodes</ingroup>
			<ingroup>g_transformationNodes</ingroup>
		</doxygen>
		<sf name="plane" doc="Specifies the clipping plane.">
			<type name="Plane" namespace="vgm" default="vgm::Vec3f(1.f, 0.f, 0.f), 0.f "></type>
		</sf>
		<of name="on" doc="Specifies if the clipping plane is enabled or disabled.">
			<type name="bool" default="true"/>
		</of>
	</node>


	<node name = "CullFace" inherits="SingleAttribute" >
		<doxygen>
			<docBrief>Cull face facets definition node</docBrief>
			<doc>The CullFace node specifies whether front-facing and/or back-facing facets can be culled.</doc>
			<doc>Facets include triangles, quadrilaterals, polygons and rectangles.</doc>
			<doc>FrontFace node specifies which of the clockwise and counterclockwise facets are front-facing and back-facing.</doc>
			<doc>See vgd::node::FrontFace.</doc>
			<ingroup>g_nodes</ingroup>
			<ingroup>g_singleAttributeNodes</ingroup>
			<ingroup>g_propertiesNodes</ingroup>
		</doxygen>
		<sf name="mode" doc="Specifies whether front-facing and/or back-facing facets can be culled.">
			<type name="enum">
				<enum default="DISABLED">
					<value name="DISABLED" doc="Facet culling is disabled"/>
					<value name="BACK" doc="Back-facing facets are culled"/>
					<value name="FRONT" doc="Front-facing facets are culled"/>
					<value name="FRONT_AND_BACK" doc="Front-facing and back-facing facets are culled"/>
				</enum>
			</type>
		</sf>
	</node>


	<node name = "DirectionalLight" inherits = "Light" >
		<doxygen>
			<docBrief>Node representing a directional light source.</docBrief>
			<doc>This node defines a directional light source that illuminates along rays parallel to a given 3-dimensional vector.</doc>
			<ingroup>g_nodes</ingroup>
			<ingroup>g_multiAttributeNodes</ingroup>
			<ingroup>g_coloringAndLightingNodes</ingroup>
		</doxygen>

		<of name="direction" doc="Direction of the light.">
			<type name = "Vec3f" namespace="vgm" default="0.f, 0.f, -1.f"></type>
		</of>
	</node>


	<node name = "FrameBuffer" inherits = "SingleAttribute" >
		<doxygen>
			<docBrief>Node representing the current framebuffer.</docBrief>
			<doc>This node specifies which color(s)/depth/stencil buffers are to be drawn into.</doc>
			<ingroup>g_nodes</ingroup>
			<ingroup>g_singleAttributeNodes</ingroup>
			<ingroup>g_frameBufferNodes</ingroup>
		</doxygen>
	</node>


	<node name = "FrontFace" inherits = "SingleAttribute" >
		<doxygen>
			<docBrief>Front face polygons definition node</docBrief>
			<doc>The FrontFace node specifies if polygons are in clockwise winding in window coordinates, or counterclockwise winding in window coordinates, are taken to be front-facing.</doc>
			<ingroup>g_nodes</ingroup>
			<ingroup>g_singleAttributeNodes</ingroup>
			<ingroup>g_propertiesNodes</ingroup>
		</doxygen>
		<sf name="orientation" doc="Specifies if front facing polygons are clockwise (CW) or conterclockwise (CCW)">
			<type name="enum">
				<enum default="CCW">
					<value name="CCW" doc="(C)ounter-(C)lock(W)ise ordering"/>
					<value name="CW" doc="(C)lock(W)ise ordering"/>
				</enum>
			</type>
		</sf>
	</node>


	<node name = "Light" inherits = "MultiAttribute" abstract = "true" >
		<doxygen>
			<docBrief>Abstract base class for all light source nodes</docBrief>
			<doc>Light is the abstract base class for all light nodes. A light node defines an illumination</doc>
			<doc>source that may affect subsequent shapes in the scene graph, depending on the current lighting</doc>
			<doc>style. Light sources are affected by the current transformation. A light node under a separator</doc>
			<doc>does not affect any objects outside that separator.</doc>
			<doc>@remarks The maximum number of lights is equal at least to 8 in OpenGL and DirectX. Feel free to use up to 8 lights. @todo Removes this limits</doc>
			<doc>@todo Support for attenuation</doc>
			<doc>@todo High-level method for changing intensity of color.</doc>
			<ingroup>g_abstractNodes</ingroup>
		</doxygen>
		<of name="on" doc="Determines whether the source is active or inactive. When inactive, the source does not illuminate at all. Set to true to switch on the light, false to switch off the light.">
			<type name="bool" default="false"></type>
		</of>
		<of name="ambient" doc="Ambient intensity of the light.">
			<type name="Vec4f" namespace="vgm" default="0.f, 0.f, 0.f, 0.f"></type>
		</of>
		<of name="diffuse" doc="Diffuse intensity of the light.">
			<type name="Vec4f" namespace="vgm" default="1.f, 1.f, 1.f, 0.f"></type>
		</of>
		<of name="specular" doc="Specular intensity of the light.">
			<type name="Vec4f" namespace="vgm" default="1.f, 1.f, 1.f, 0.f"></type>
		</of>

		<sf name="castShadow" doc="Indicating that this light casts a shadow.">
			<type name="bool" default="false"></type>
		</sf>

		<includehpp>vgd/include/vgd/node/Light.hpp</includehpp>
		<includecpp>vgd/src/node/Light.cpp</includecpp>
	</node>


	<!-- TODO Split this node => ShadowStyle/Properties -->
	<node name = "LightModel" inherits = "SingleAttribute" >
		<doxygen>
			<docBrief>Lighting model node</docBrief>
			<doc>This node specifies current lighting mode (off/standard per vertex lighting/standard per pixel lighting) and some options of the lighting model.</doc>
			<ingroup>g_nodes</ingroup>
			<ingroup>g_singleAttributeNodes</ingroup>
			<ingroup>g_coloringAndLightingNodes</ingroup>
		</doxygen>

		<of name="model" doc="Sets the lighting model to LIGHTING_OFF, STANDARD_PER_VERTEX or STANDARD_PER_PIXEL.">
			<type name="enum">
				<enum default="STANDARD_PER_VERTEX">
					<value name="LIGHTING_OFF"			doc="No lighting"/>
					<value name="STANDARD_PER_VERTEX"	doc="Lighting is computed per vertex"/>
					<value name="STANDARD_PER_PIXEL"	doc="Lighting is computed per pixel"/>
				</enum>
			</type>
		</of>

		<of name="ambient" doc="Sets the ambient RGBA intensity of the entire scene.">
			<type name="Vec4f" namespace="vgm" default="0.2f, 0.2f, 0.2f, 0.0f"></type>
		</of>

		<of name="viewer" doc="Specifies how specular reflection angles are computed. Possible values :
- AT_INFINITY specular reflections are computed from the origin of the eye coordinate system.
- AT_EYE specular reflection angles take the view direction to be parallel to and in the direction of the -z axis, regardless of the location of the vertex in eye coordinates.">
			<type name="enum">
				<enum default="AT_INFINITY">
					<value name="AT_INFINITY"	doc="Specular reflections are computed from the origin of the eye coordinate system"/>
					<value name="AT_EYE"		doc="Specular reflection angles take the view direction to be parallel to and in the direction of the -z axis, regardless of the location of the vertex in eye coordinates"/>
				</enum>
			</type>
		</of>

		<of name="twoSided" doc="Specifies whether one- or two-sided lighting calculations are done for polygons and triangles.">
			<type name="bool" default="false"></type>
		</of>

		<of name="shadow" doc="Specifies the algorithm used to compute shadow.">
			<type name="enum">
				<enum default="SHADOW_OFF">
					<value name="SHADOW_OFF"			doc="Shadows are not computed"/>
					<value name="SHADOW_MAPPING"		doc="Shadows are computed using shadow mapping algorithm"/>
					<value name="SHADOW_MAPPING_4U"		doc="Four uniform samples"/>
					<value name="SHADOW_MAPPING_4DM"	doc="Four dithered samples"/>
					<value name="SHADOW_MAPPING_16U"	doc="Sixteen uniform samples"/>
					<value name="SHADOW_MAPPING_16UM"	doc="Sixteen unifrom samples"/>
					<value name="SHADOW_MAPPING_32U"	doc="Thirty two uniform samples"/>
					<value name="SHADOW_MAPPING_32UM"	doc="Thirty two uniform samples"/>
					<value name="SHADOW_MAPPING_64U"	doc="Sixty four uniform samples"/>
					<value name="SHADOW_MAPPING_64UM"	doc="Sixty four uniform samples"/>
					<!-- @todo custom -->
				</enum>
			</type>
		</of>

		<sf name="samplingSize" doc="">
			<type name="float" default="1.0"/>
		</sf>
		
		<of name="shadowQuality" doc="Specifies the quality of the shadow computation">
			<type name="enum">
				<enum default="MEDIUM">
					<value name="LOW"		doc="Low resolution shadow map"/>
					<value name="MEDIUM"	doc="Medium resolution shadow map"/>
					<value name="HIGH"		doc="High resolution shadow map"/>
					<value name="VERY_HIGH"	doc="Very high resolution shadow map"/>
				</enum>
			</type>
		</of>

		<sf name="shadowMapType" doc="">
			<type name="enum">
				<enum default="INT32">
					<value name="INT16"		doc="see Texture.internalFormat documentation"/>
					<value name="INT24"		doc="see Texture.internalFormat documentation"/>
					<value name="INT32"		doc="see Texture.internalFormat documentation"/>
					<value name="FLOAT32"	doc="see Texture.internalFormat documentation"/>
				</enum>
			</type>
		</sf>

		<sf name="illuminationInShadow" doc="value=[0,1] : 0 full attenuation in shadow, 1 no attenuation in shadow">
			<type name="float" default="0.4f"></type>
		</sf>

		<sf name="shadowPolygonOffset" doc="">
			<type name="Vec2f" namespace="vgm" default="4.f, 16.f"></type>
		</sf>

		<of name="useShadowSamplers" doc="True to use GLSL shadowSampler, false to use traditionnal texture sampler.">
			<type name="bool" default="true"/>
		</of>

		<sf name="postProcessing" doc="True to enable post-processing, false to disable it">
			<type name="bool" default="false"/>
		</sf>
	</node>


	<node name = "Material" inherits = "SingleAttribute" >
		<doxygen>
			<docBrief>Surface material definition node</docBrief>
			<doc>The Material node specifies current surface material properties for all subsequent shapes nodes</doc>
			<doc> and is used by the lighting equations during rendering.</doc>
			<doc>The field \c opacity (alpha value) is used in the lighting computation only for the diffuse alpha component.</doc>
			<doc>The field \c transparency is not optional because it is used by others fields (in OpenGL ambient and others use 4 floats).</doc>
			<ingroup>g_nodes</ingroup>
			<ingroup>g_singleAttributeNodes</ingroup>
			<ingroup>g_coloringAndLightingNodes</ingroup>
		</doxygen>

		<sf name="opacity" doc="Sets opacity from 1.0 for being completely opaque until 0.0 for being completely transparent.">
			<type name="float" default="1.f"></type>
		</sf>

		<of name="ambient" doc="Ambient color of the surface.">
			<type name="Vec3f" namespace="vgm" default="0.2f, 0.2f, 0.2f"/>
		</of>

		<of name="diffuse" doc="Diffuse color of the surface.">
			<type name="Vec3f" namespace="vgm" default="0.8f, 0.8f, 0.8f"/>
		</of>

		<of name="specular" doc="Specular color of the surface.">
			<type name="Vec3f" namespace="vgm" default="0.f, 0.f, 0.f"/>
		</of>

		<of name="emission" doc="Emmissive color of the surface.">
			<type name="Vec3f" namespace="vgm" default="0.f, 0.f, 0.f"/>
		</of>

		<of name="shininess" doc="Shininess coefficient of the surface. Values can range from 0.0 for no shininess (a diffuse surface) to 1.0 for maximum shininess (a highly polished surface).">
			<type name="float" default="0.f"></type>
		</of>

<!--		<of name="face" doc="Specifies which face(s) are being updated.">
			<type name="enum">
				<enum default="FRONT_AND_BACK">
					<value name="BACK" doc="Back-facing facets are updated"/>
					<value name="FRONT" doc="Front-facing facets are updated"/>
					<value name="FRONT_AND_BACK" doc="Front-facing and back-facing facets are updated"/>
				</enum>
			</type>
		</of>-->

		<includehpp>vgd/include/vgd/node/Material.hpp</includehpp>
		<includecpp>vgd/src/node/Material.cpp</includecpp>
<!--	<codehpp></codehpp> <codecpp></codecpp> -->
	</node>


	<node name = "MultipleInstances" inherits = "Shape">
		<doxygen>
			<docBrief>Instanciated the same object multiple times in the scene</docBrief>
			<doc>The object, defined by the shape field, is instanciated once per matrix available in the field named matrix.</doc>
			<doc>The matrix is concatenated to the current geometrical transformation matrix.</doc>
			<doc>This allows the user to put multiple copies of the same data in different locations easily and efficiently.</doc>
			<doc>@todo really implements vgd::node::IBoundingBox interface. useful ?</doc>
			<ingroup>g_nodes</ingroup>
			<ingroup>g_shapeNodes</ingroup>
			<ingroup>g_transformationNodes</ingroup>
		</doxygen>

		<sf name = "shape" doc = "The object to instanciate multiple times.">
			<type name = "NodeShp" namespace = "vgd::node"></type>
		</sf>

		<mf name = "matrix" doc = "The array of matrices used to transform the object in different locations">
			<type name = "MatrixR" namespace="vgm"></type>
		</mf>

		<includehpp>vgd/include/vgd/node/MultipleInstances.hpp</includehpp>
		<includecpp>vgd/src/node/MultipleInstances.cpp</includecpp>
	</node>


	<node name = "OutputBuffers" inherits = "SingleAttribute">
		<doxygen>
			<docBrief>Select which buffers to use for drawing</docBrief>
			<doc>This node affect subsequent shapes in the scene graph.</doc>
			<doc>But if this node is under a separator, it does not affect any objects outside that separator.</doc>
			<doc>@todo Adds support for more than 2 different output buffers</doc>
			<ingroup>g_nodes</ingroup>
			<ingroup>g_singleAttributeNodes</ingroup>
			<ingroup>g_frameBufferNodes</ingroup>
		</doxygen>

		<sf name = "output" doc = "Specifies the buffers used for rendering.">
			<type name="enum">
				<enum default="BUFFERS0">
					<value name="BUFFERS0" doc="Selects color buffer 0 and a depth buffer 0"/>
					<value name="BUFFERS1" doc="Selects color buffer 1 and a depth buffer 1"/>
					<value name="BUFFERS2" doc="Selects color buffer 2 and a depth buffer 2"/>
				</enum>
			</type>
		</sf>
	</node>


	<node name = "PointLight" inherits = "Light" >
		<doxygen>
			<docBrief>Node representing a point light source.</docBrief>
			<doc>A point source illuminates equally in all directions. It is omni-directional.</doc>
			<doc>All shape nodes that come after this light in the scene graph are illuminated by this light.</doc>
			<doc>The light's location is affected by the current geometrical transformation.</doc>
			<ingroup>g_nodes</ingroup>
			<ingroup>g_multiAttributeNodes</ingroup>
			<ingroup>g_coloringAndLightingNodes</ingroup>
		</doxygen>

		<of name = "position" doc = "Location of the light source.">
			<type name = "Vec3f" namespace = "vgm" default = "0.f, 0.f, 1.f"></type>
		</of>
	</node>


	<node name = "PointStyle" inherits="SingleAttribute" >
		<doxygen>
			<docBrief>Defines the style to use when rendering points</docBrief>
			<ingroup>g_nodes</ingroup>
			<ingroup>g_singleAttributeNodes</ingroup>
			<ingroup>g_propertiesNodes</ingroup>
		</doxygen>
		<of name="size" doc="Specifies the rasterized diameter of both aliased and antialiased points">
			<type name = "float" default = "1.f"></type>
		</of>

		<of name="distanceAttenuation" doc="a vector of three floating-point values that specify the coefficients used for scaling the computed point size. The default values are (1 0 0).">
			<type name = "Vec3f" namespace="vgm" default = "1.f, 0.f, 0.f"></type>
		</of>

		<of name="smooth" doc="If enabled, draw antialiased points, otherwise draw aliased points. Ignored when point sprite is enabled.">
			<type name = "bool" default = "false"></type>
		</of>

		<of name="pointSprite" doc="See GL_ARB_point_sprite extension for details (http://oss.sgi.com/projects/ogl-sample/registry/ARB/point_sprite.txt).">
			<type name = "bool" default = "false"></type>
		</of>
	</node>


	<node name = "PostProcessing" inherits = "MultiAttribute" >
		<doxygen>
			<docBrief>A single stage of a post-processing stage.</docBrief>
			<doc>This node defines a single stage of a post-processing stage.</doc>
			<doc>Post-processing effect is applied to the previously rendered scene using COLOR and/or NORMAL buffer(s)</doc>
			<ingroup>g_nodes</ingroup>
			<ingroup>g_multiAttributeNodes</ingroup>
			<ingroup>g_texturingNodes</ingroup>
			<ingroup>g_frameBufferNodes</ingroup>
		</doxygen>

		<sf name = "filter" doc = "Specifies the filter to apply to the input buffers.">
			<type name = "enum">
				<enum default="NO_FILTER">
					<value name="COLOR_TO_MONOCHROME" doc="Converts colored value to black and white"/>
					<value name="COLOR_TO_SEPIA" doc="Converts colored value to sepia.\nSets desaturate parameter(default 0.5f, min 0.0f, max 1.0f) into param4f0[0]. Sets toning parameter ( default 1.f, min 0.0f, max 1.0f) into param4f0[1]."/>
					<value name="COLOR_INVERSE" doc="Inverts the colored value"/>

					<value name="SCALE_AND_BIAS" doc="Each of the color components is multiplied by a scale factor, then added to a bias factor using the following formula : output = input0 * param4f0 + vec4(param1f0)."/>

					<value name="BLUR_HORIZ" doc="Blurs an image horizontally using weights that follow a Gaussian distribution. Bloom scale could be specify using param1f0."/>
					<value name="BLUR_VERT" doc="Blurs an image vertically using weights that follow a Gaussian distribution. Bloom scale could be specify using param1f0"/>
					<value name="BLOOM_HORIZ" doc="Amplifies and blurs an image horizontally using weights that follow a gaussian distribution"/>
					<value name="BLOOM_VERT" doc="Amplifies and blurs an image vertically using weights that follow a gaussian distribution"/>

					<value name="COLOR_EDGE_DETECT" doc="Detects edges and highlights them"/>

					<value name="DOWN_FILTER4" doc="Scales images down 4 times with a high-pass filter"/>
					<value name="UP_FILTER4" doc="Scales images up 4 times"/>

<!--					<value name="NORMAL_EDGE_DETECT" doc="Detects edges and highlights them (using NORMAL buffer)"/> -->

					<value name="OVER" doc="Composes two images using an over filter. The input0 source is composited over the input1 source. @todo uses alpha instead black to decide composition"/>
					<value name="ADD" doc="Combines two images into one by blending them linearly using the following formula : image1 + image2"/>
					<value name="MIX_AND_SCALE" doc="Combines two images into one by blending them linearly using the following formula : image1 * (1-a) + image2 * a with a = param4f0[0].\nThen the resulting image is multiplied by a scale factor : previousComputation *=scale with scale = param4f0[1]"/>
					<value name="COMBINE2_AND_SCALE" doc="Combines two images into one by blending them linearly using the following formula : image1 * a + image2 * b with a = param4f0[0] and b = param4f0[1].\nThen the resulting image is multiplied by a scale factor : previousComputation *=scale with scale = param4f0[2]"/>
					<value name="COMBINE3_AND_SCALE" doc="Combines three images into one by blending them linearly using the following formula : image1 * a + image2 * b + image3 * c with a = param4f0[0], b = param4f0[1] and c = param4f0[2].\nThen the resulting image is multiplied by a scale factor : previousComputation *=scale with scale = param4f0[3]"/>

					<value name="DOF" doc="@todo"/>

					<value name="NO_FILTER" doc="No filter is applied"/>
				</enum>
			</type>
		</sf>

		<sf name = "input0" doc = "Specifies the first input buffer used by the filter.">
			<type name = "enum">
				<enum default = "PREVIOUS_COLOR0">
					<value name="ORIGINAL_COLOR0" doc=""/>
					<value name="ORIGINAL_DEPTH0" doc=""/>
					<value name="ORIGINAL_COLOR1" doc=""/>
					<value name="ORIGINAL_DEPTH1" doc=""/>
					<value name="ORIGINAL_COLOR2" doc=""/>
					<value name="ORIGINAL_DEPTH2" doc=""/>
					<value name="ORIGINAL_NORMAL" doc=""/>
					<value name="ORIGINAL_POSITION" doc=""/>
					<value name="PREVIOUS_COLOR0" doc=""/>
					<value name="PREVIOUS_COLOR1" doc=""/>
					<value name="NONE" doc=""/>
				</enum>
			</type>
		</sf>

		<sf name = "input1" doc = "Specifies the second input buffer used by the filter.">
			<type name = "enum">
				<enum default = "INPUT1_NONE">
					<value name="INPUT1_ORIGINAL_COLOR0" doc=""/>
					<value name="INPUT1_ORIGINAL_DEPTH0" doc=""/>
					<value name="INPUT1_ORIGINAL_COLOR1" doc=""/>
					<value name="INPUT1_ORIGINAL_DEPTH1" doc=""/>
					<value name="INPUT1_ORIGINAL_COLOR2" doc=""/>
					<value name="INPUT1_ORIGINAL_DEPTH2" doc=""/>
					<value name="INPUT1_ORIGINAL_NORMAL" doc=""/>
					<value name="INPUT1_ORIGINAL_POSITION" doc=""/>
					<value name="INPUT1_PREVIOUS_COLOR0" doc=""/>
					<value name="INPUT1_PREVIOUS_COLOR1" doc=""/>
					<value name="INPUT1_NONE" doc=""/>
				</enum>
			</type>
		</sf>

		<sf name = "input2" doc = "Specifies the third input buffer used by the filter.">
			<type name = "enum">
				<enum default = "INPUT2_NONE">
					<value name="INPUT2_ORIGINAL_COLOR0" doc=""/>
					<value name="INPUT2_ORIGINAL_DEPTH0" doc=""/>
					<value name="INPUT2_ORIGINAL_COLOR1" doc=""/>
					<value name="INPUT2_ORIGINAL_DEPTH1" doc=""/>
					<value name="INPUT2_ORIGINAL_COLOR2" doc=""/>
					<value name="INPUT2_ORIGINAL_DEPTH2" doc=""/>
					<value name="INPUT2_ORIGINAL_NORMAL" doc=""/>
					<value name="INPUT2_ORIGINAL_POSITION" doc=""/>
					<value name="INPUT2_PREVIOUS_COLOR0" doc=""/>
					<value name="INPUT2_PREVIOUS_COLOR1" doc=""/>
					<value name="INPUT2_NONE" doc=""/>
				</enum>
			</type>
		</sf>
			<!-- TODO enum for input1 should be the same as input0 => specify enum at node level
			<type name = "enum">
				<enum default = "INPUT1_PREVIOUS_COLOR">
					<value name="INPUT1_ORIGINAL_COLOR" doc=""/>
					<value name="INPUT1_ORIGINAL_NORMAL" doc=""/>
					<value name="INPUT1_PREVIOUS_COLOR" doc=""/>
					<value name="INPUT1_NONE" doc=""/>
				</enum>
			</type>-->

		<of name = "param1f0" doc = "Specifies the first 1f parameter used by the filter.">
			<type name = "float" default = "0.0"></type>
		</of>

		<of name = "param4f0" doc = "Specifies the first 4f parameter used by the filter.">
			<type name = "Vec4f" namespace = "vgm" default = "0.0, 0.0, 0.0, 0.0"></type>
		</of>

		<sf name ="output" doc = "Specifices the output buffer used by the filter.">
			<type name = "enum">
				<enum default = "OUTPUT_TMP0">
					<value name="OUTPUT_TMP0" doc=""/>
					<value name="OUTPUT_TMP1" doc=""/>
				</enum>
			</type>
		</sf>

<!-- convolution filter and param [] -->
<!-- custom filter -->
<!-- filter0, filter1, filter2 -->
<!-- ouput0, output1.... -->
	</node>


	<node name = "SpotLight" inherits = "PointLight" >
		<doxygen>
			<docBrief>Node representing a spotlight source.</docBrief>
			<doc>This node defines a spotlight style light source.</doc>
			<doc>A spotlight is placed at a fixed \c position in 3-space and illuminates in a cone along a particular \c direction.</doc>
			<doc>The illumination is within a cone whose angle is given by the \c cutOffAngle field.</doc>
			<doc>The intensity of the illumination drops off exponentially as a ray of light diverges from this direction toward the edges of the cone.</doc>
			<doc>The rate of drop-off and the angle of the cone are controlled by the \c dropOffRate and \c cutOffAngle fields.</doc>
			<doc>All shape nodes that come after this light in the scene graph are illuminated by this light.</doc>
			<doc>The light's location is affected by the current geometrical transformation.</doc>
			<ingroup>g_nodes</ingroup>
			<ingroup>g_multiAttributeNodes</ingroup>
			<ingroup>g_coloringAndLightingNodes</ingroup>
		</doxygen>

		<of name = "direction" doc = "The direction (center axis of cone) of the light in homogeneous object coordinates.">
			<type name = "Vec3f" namespace = "vgm" default = "0.f, 0.f, -1.f"></type>
		</of>

		<of name = "cutOffAngle" doc = "The angle (in degree) outside of which intensity is zero, measured from the center axis of the cone to an edge. This value must be inside [0, 90] or be equal to 180 (like PointLight node).">
			<type name = "float" default = "90.f"></type>
		</of>

		<of name = "dropOffRate" doc = "Rate of intensity drop-off per change in angle from primary direction. 0 means constant intensity, 1 means very sharp drop-off.">
			<type name = "float" default = "0.f"></type>
		</of>
	</node>


<!--TEXTURE_GEN_MODE
	OBJECT_LINEAR, EYE_LINEAR, SPHERE_MAP, NORMAL_MAP, or REFLECTION_MAP -->

	<node name = "TexGen" inherits = "MultiAttribute" abstract = "true" >
		<doxygen>
			<docBrief>Abstract node to control the generation of texture coordinates S, T, R and Q.</docBrief>
			<ingroup>g_abstractNodes</ingroup>
		</doxygen>

		<sf name="on" doc="Specifies if the texture generation is enabled or disabled.">
			<type name="bool" default="true"/>
		</sf>
	</node>

	<node name = "TexGenEyeLinear" inherits = "TexGen" >
		<doxygen>
			<docBrief>Generating texture coordinates using eye linear function</docBrief>
			<doc>See OpenGL specification for details</doc>
			<ingroup>g_nodes</ingroup>
			<ingroup>g_multiAttributeNodes</ingroup>
			<ingroup>g_texturingNodes</ingroup>
		</doxygen>

		<of name = "parameters" doc = "" >
			<type name = "MatrixR" namespace = "vgm" default = "vgm::MatrixR::getIdentity()"></type>
		</of>
	</node>

<!-- improves doc tag -->
	<node name = "Texture" inherits = "MultiAttribute" abstract = "true" >
		<doxygen>
			<docBrief>Abstract texture mapping node</docBrief>
			<doc>This node defines texture parameters (wrapping, filter for minifying and magnification, mipmapping and function).</doc>
			<doc>Be carefull, data referenced by image must be available when texture is update.</doc>
			<doc>This node creates a a texture from the iimage interface. So image could be an image stored in memory (with vgd::basic::ImageInfo) or from a file (with vgd::basic::Image) or a cairo image (with vgCairo::ImageSurface)</doc>
			<doc>@remarks When The scene graph is evaluated by vgeGL, there are a size constraint one texture that you should keep in mind.\n</doc>
			<doc>When the image exceed the maximum allowable size for the texture, a temporary resized copy of the \c iimage(to the maximum of the texture size) is used for defining texture. This is not very fast. Be carefull.\n</doc>
			<doc>- Radeon 8500 could do 2048 x 2048 for 2D texturing, 512 x 512 x 512 for 3D texturing and 2048 for cube mapping.\n</doc>
			<doc>- GeForce 2 could do 2048 x 2048 for 2D texturing, 64 x 64 x 64 for 3D texturing and 512 for cube mapping.\n</doc>
			<doc>- GeForce 3 could do 4096 x 4096 for 2D texturing, 512 x 512 x 512 for 3D texturing and 4096 for cube mapping.\n</doc>
			<doc>- GeForce FX could do 4096 x 4096 for 2D texturing, 512 x 512 x 512 for 3D texturing and 4096 for cube mapping.\n</doc>
			<doc>- GeForce 8 could do  8192 x 8192 for 2D texturing, 2048 x 2048 x 2048 for 3D texturing and 8192 for cube mapping.\n</doc>
			<doc>@remarks If your OpenGL implementation does'nt support advanced texturing not limited to images with power-of-two dimensions, a temporary resized copy of the \c iimage is used for all wrapping modes except \c ONCE.\n</doc>
			<doc>@todo More docs\n</doc>
			<ingroup>g_abstractNodes</ingroup>
		</doxygen>

		<of name = "image" doc = "Determines the source of data used to created the texture. You can set multiple times this field, but only if all successive images have the same format. The data and size of the image can changed, but that's all.">
			<type name = "IImageShp" namespace = "vgd::basic"></type>
		</of>

<!-- @todo Declare a new enum here to be shared by several fields -->
<!-- @todo <of name = "wrapS" doc=""> </of> -->

		<paf name = "wrap" doc = "Sets the wrap parameter for texture coordinate S, T or R to either REPEAT, CLAMP, CLAMP_TO_EDGE, CLAMP_TO_BORDER, MIRRORED_REPEAT or ONCE. Initially, this field is set to REPEAT for S, T and R." >
			<type name="enum">
				<enum default="WRAP_S">
					<value name="WRAP_S" doc=""/>
					<value name="WRAP_T" doc=""/>
					<value name="WRAP_R" doc=""/>
				</enum>
			</type>
			<type name="enum">
				<enum default="REPEAT">
					<value name="REPEAT" doc=""/>
					<value name="CLAMP" doc=""/>
					<value name="CLAMP_TO_EDGE" doc=""/>
					<value name="CLAMP_TO_BORDER" doc=""/>
					<value name="MIRRORED_REPEAT" doc=""/>
					<value name="ONCE" doc="Don't set texture coordinates outside the interval [0.f, 1.f]"/>
				</enum>
			</type>
		</paf>

		<paf name = "filter" doc ="The texture minifying function (MIN_FILTER) is used whenever the pixel being textured maps to an area greater than one texture element. The texture magnification function (MAG_FILTER) is used when the pixel being textured maps to an area less than or equal to one texture element." >
			<type name="enum">
				<enum default="MAG_FILTER">
					<value name="MIN_FILTER" doc="Choose one value among NEAREST, LINEAR (default), NEAREST_MIPMAP_NEAREST, LINEAR_MIPMAP_NEAREST, NEAREST_MIPMAP_LINEAR, LINEAR_MIPMAP_LINEAR."/>
					<value name="MAG_FILTER" doc="Choose one value among NEAREST or LINEAR (default)."/>
				</enum>
			</type>
			<type name="enum">
				<enum default="LINEAR">
					<value name="NEAREST" doc=""/>
					<value name="LINEAR" doc=""/>
					<value name="NEAREST_MIPMAP_NEAREST" doc=""/>
					<value name="LINEAR_MIPMAP_NEAREST" doc=""/>
					<value name="NEAREST_MIPMAP_LINEAR" doc=""/>
					<value name="LINEAR_MIPMAP_LINEAR" doc=""/>
				</enum>
			</type>
		</paf>

		<of name = "mipmap" doc="Specifies if all levels of a mipmap array should be automatically updated when any modification to the image field (the base level of mipmap) is done." >
			<type name="bool" default="false"/>
		</of>

<!-- @todo Choose a value among FUN_REPLACE, FUN_MODULATE, FUN_DECAL, FUN_BLEND, FUN_ADD and FUN_COMBINE. -->
		<of name = "function" doc="Example similar to old FUN_MODULATE: color *= texture2D(texUnitX, gl_TexCoord[X].xy);" >
			<type name="string" namespace="std"/>
		</of>

		<sf name = "usage" doc="Indicating the expected usage pattern of the texture.">
			<type name="enum">
				<enum default = "IMAGE">
					<value name="IMAGE" doc="Simple image mapping"/>
					<value name="SHADOW" doc="Shadow mapping"/>
				</enum>
			</type>
		</sf>

		<sf name = "internalFormat" doc="Specifies the desired internal format used by the GPU.">
			<type name="enum">
				<enum default="AUTOMATIC">
					<value name="AUTOMATIC"	doc="Choosed automatically an internal format matching the image format used by the texture."/>
					<value name="DEPTH_COMPONENT_16" doc="a single component buffer used to store depth. A 16-bit integer is used to encode a texel."/>
					<value name="DEPTH_COMPONENT_24" doc="a single component buffer used to store depth. A 24-bit integer is used to encode a texel."/>
					<value name="DEPTH_COMPONENT_32" doc="a single component buffer used to store depth. A 32-bit integer is used to encode a texel."/>
					<value name="DEPTH_COMPONENT_32F" doc="a single component buffer used to store depth. A 32-bit float is used to encode a texel."/>
					<value name="RGB_16F" doc="A three component buffer. A 16-bit float is used to encode a texel."/>
					<value name="RGB_32F" doc="A three component buffer. A 32-bit float is used to encode a texel."/>
					<value name="RGBA_16F" doc="A four component buffer. A 16-bit float is used to encode a texel."/>
					<value name="RGBA_32F" doc="A four component buffer. A 32-bit float is used to encode a texel."/>
					<value name="LUMINANCE_16F" doc="A single component buffer. A 16-bit float is used to encode a texel."/>
					<value name="LUMINANCE_32F" doc="A single component buffer. A 32-bit float is used to encode a texel."/>
					<value name="LUMINANCE_ALPHA_16F" doc="A two component buffer. A 16-bit float is used to encode a texel."/>
					<value name="LUMINANCE_ALPHA_32F" doc="A two component buffer. A 32-bit float is used to encode a texel."/>
				</enum>
			</type>
		</sf>

<!-- image format depth
 GL_TEXTURE_COMPARE_MODE
 GL_TEXTURE_COMPARE_FUNC
 usage SHADOWMAP -->

 		<includehpp>vgd/include/vgd/node/Texture.hpp</includehpp>
 		<includecpp>vgd/src/node/Texture.cpp</includecpp>
	</node>

	<node name = "Texture1D" inherits = "Texture" >
		<doxygen>
			<docBrief>Texture mapping node</docBrief>
			<doc>This property node defines a texture map and parameters for that map. This map is used to apply texture to subsequent shapes as they are rendered.</doc>
			<doc>@remarks Must be a 1d image (iimage.height() == iimage.depth() == 0).</doc>
			<ingroup>g_nodes</ingroup>
			<ingroup>g_multiAttributeNodes</ingroup>
			<ingroup>g_texturingNodes</ingroup>
		</doxygen>
		<includehpp>vgd/include/vgd/node/Texture1D.hpp</includehpp>
		<includecpp>vgd/src/node/Texture1D.cpp</includecpp>
	</node>

	<node name = "Texture2D" inherits = "Texture" >
		<doxygen>
			<docBrief>Texture mapping node</docBrief>
			<doc>This property node defines a texture map and parameters for that map. This map is used to apply texture to subsequent shapes as they are rendered.</doc>
			<ingroup>g_nodes</ingroup>
			<ingroup>g_multiAttributeNodes</ingroup>
			<ingroup>g_texturingNodes</ingroup>
		</doxygen>
		<includehpp>vgd/include/vgd/node/Texture2D.hpp</includehpp>
		<includecpp>vgd/src/node/Texture2D.cpp</includecpp>
	</node>



<!-- @todo abstract class -->



<!--	<node	name = "MaterialExt"
			inherits="Material">
		<doxygen>
			<docBrief>Extended surface material definition node</docBrief>
			<doc>The Material node specifies current surface material properties for all subsequent shapes nodes</doc>
			<doc> and is used by the lighting equations during rendering.</doc>
			<doc>The field \c transparency is not optional because it is used by others fields (in OpenGL ambient and others use 4 floats).</doc>
			<ingroup>g_nodes</ingroup>
			<ingroup>g_singleAttributeNodes</ingroup>
			<ingroup>g_coloringAndLightingNodes</ingroup>
		</doxygen>
	</node>-->

<!-- todo
	<node	name="SingleAttribute">
	</node> -->
</nodes>

<!-- test default value code generator
			<type name="float"></type>
			<type name="float" default="1.f"></type>
			<type name="Plane" namespace="vgm"></type>
			<type name="Plane" namespace="vgm" default=" "></type>
			<type name="Plane" namespace="vgm" default=" 0, 1, 2"></type>-->
