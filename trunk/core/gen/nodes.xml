<?xml version="1.0"?>

<!--	VGSDK - Copyright (C) 2008, 2009, 2010, 2011, Nicolas Papier.
	Distributed under the terms of the GNU Library General Public License (LGPL)
	as published by the Free Software Foundation.
	Author Nicolas Papier -->

<nodes>

<!-- todo defines an enum here -->

	<node	name		= "Camera"
			inherits	= "GeometricalTransformation ProjectionTransformation">
		<doxygen>
			<docBrief>Camera node used to set the projection matrix, viewport and scissor box. Camera position and orientation could be specified too.</docBrief>
			<doc>Sets up the rendering mode (monoscopic and 3D stereoscopic) using \c mode field.</doc>
			<doc>In stereoscopic mode, \c projectionRight (resp. \c projectionLeft) and \c lookAtRight (resp. \c lookAtLeft) specifies the right (resp. left) eye.</doc>
			<doc>Sets up the \c projection with an user defined matrix for the viewing frustum (into the world coordinate system).</doc>
			<doc>Sets up the camera position and orientation with 4x4 matrix from \c lookAt field.</doc>
			<doc>Note that some matrices (such as singular ones) may result in errors in bounding boxes, picking, and lighting.</doc>
			<ingroup>g_nodes</ingroup>
			<ingroup>g_singleAttributeNodes</ingroup>
			<ingroup>g_transformationNodes</ingroup>
		</doxygen>

		<!--Defines which eye(s) must be considered (mainly used in ClearFrameBuffer and Camera). -->
		<enum name="EyeUsagePolicy"	default="EYE_BOTH">
			<value name="EYE_LEFT"	doc="the left eye"/>
			<value name="EYE_RIGHT"	doc="the right eye"/>
			<value name="EYE_BOTH"	doc="the left eye and right eye"/>
		</enum>

		<!-- projection and lookAt renames into intrinsics and extrinsics -->

		<sf name="projectionLeft" doc="Determines the projection matrix for monoscopic rendering or for the left eye if stereo is enabled.">
			<type name="MatrixR" namespace="vgm" default="vgm::MatrixR::getIdentity()"></type>
		</sf>
		<sf name="lookAtLeft"
			doc="Determines the 3D geometric transformation as a 4x4 matrix applied to camera for monoscopic rendering or for the left eye if stereo is enabled.\n Note that this transformation is applied to engine like any GeometricalTransformation node with composeTransformation field sets to false.\n By default, the camera is situated at the origin, points down the negative z-axis, and has an up-vector of (0, 1, 0).">
			<type name="MatrixR" namespace="vgm" default="vgm::MatrixR::getIdentity()"></type>
		</sf>

		<sf name="projectionRight" doc="Determines the projection matrix for the right eye (used only if stereo is enabled).">
			<type name="MatrixR" namespace="vgm" default="vgm::MatrixR::getIdentity()"></type>
		</sf>
		<sf name="lookAtRight"
			doc="Determines the 3D geometric transformation as a 4x4 matrix applied to camera for the right eye (used only if stereo is enabled).\n Note that this transformation is applied to engine like any GeometricalTransformation node with composeTransformation field sets to false.\n By default, the camera is situated at the origin, points down the negative z-axis, and has an up-vector of (0, 1, 0).">
			<type name="MatrixR" namespace="vgm" default="vgm::MatrixR::getIdentity()"></type>
		</sf>

		<sf name="fovy" doc="Field of view angle for the Y direction for the camera. In the case of a perspective camera.">
			<type name="float" default="45.f"></type>
		</sf>
		<of name="aspect" doc="Aspect ratio of the camera">
			<type name="float" default="1"></type>
		</of>
		<of name="zNear" doc="Nearest visible z for the camera.">
			<type name="float" default="0.01f"></type>
		</of>
		<of name="zFar" doc="Farest visible z for the camera">
			<type name="float" default="3996.f"></type>
		</of>

		<of name="viewport" doc="Determines the viewport.">
			<type name="Rectangle2i" namespace="vgm" default="0, 0, 1600, 1200"/>
		</of>

		<of name="scissor" doc="Determines the scissor box. It is automatically enabled if this field is defined, otherwise it is disabled. The default value is empty, i.e. scissor test is disabled.">
			<type name="Rectangle2i" namespace="vgm" default=""/>
		</of>

		<sf name="mode" doc="Specifies the camera mode (monoscopic or stereoscopic mode).\n When you normally look at objects, your two eyes see slightly different images (because they are located at different viewpoints).\n Stereoscopic rendering is a technique for creating the illusion of depth in an image for the viewer. Two images are computed (one for each eye) and presented to the viewer using anaglyph (red/cyan) or quad buffer stereo (todo). The brain combined these images to given the perception of depth.">
			<type name="enum">
				<enum default="MONOSCOPIC">
					<value name="MONOSCOPIC" doc="Non stereoscopic rendering. Scene is viewed for the one eye located at \c lookAtLeft and projected with \c projectionLeft along eye direction on near plane. \c viewport and \c scissor fields are used to define the camera too."/>
					<value name="QUAD_BUFFER" doc="Stereoscopic rendering using quad buffer (i.e. active stereo using shutter glasses, or passive stereo using polarized projectors and glasses). Scene is viewer for left and right eyes. All fields are used to define the camera."/>
					<value name="ANAGLYPH" doc="@todo Stereoscopic rendering using red/cyan anaglyph. All fields are used to define the camera."/>
				</enum>
			</type>
		</sf>

		<sf name="eyeSeparation" doc="Sets the distance between the left and right eye.">
			<type name = "float" default = "0.f"></type>
		</sf>

		<sf name="imageShift" doc="Sets the additional horizontal shift between the left and right image. This value must be between 0 and 100. 0 means no shift at all. 100 corresponds to a shift of 1/8 of the drawing surface.">
			<type name = "float" default = "0.f"></type>
		</sf>

		<sf name="rightEye" doc="Sets to true to enabled the right eye in stereoscopic mode. Setting this field to false is helpful for debugging.">
			<type name = "bool" default = "true"></type>
		</sf>

		<includehpp>vgd/include/vgd/node/Camera.hpp</includehpp>
		<includecpp>vgd/src/node/Camera.cpp</includecpp>

	</node>


	<node name = "ClearFrameBuffer" inherits = "SingleAttribute" >
		<doxygen>
			<docBrief>Node clearing the framebuffer</docBrief>
			<ingroup>g_nodes</ingroup>
			<ingroup>g_singleAttributeNodes</ingroup>
			<ingroup>g_frameBufferNodes</ingroup>
		</doxygen>
		<of name = "clearColor" doc="Specifies the clear color.">
			<type name="Vec4f" namespace="vgm" default="0.f, 0.f, 0.f, 0.f"></type>
		</of>
	</node>


	<node name = "ClipPlane" inherits = "MultiAttribute" >
		<doxygen>
			<docBrief>Clipping plane node</docBrief>
			<doc>All subsequent shapes in the scene graph will be clipped to the half-space defined by the \c plane field.</doc>
			<doc>The half-space is the side of the plane in the direction of the plane normal.</doc>
			<doc>Any number of clipping planes may be active simultaneously, although the graphics library may place a limit on this number during rendering (i.e. 6 for OpenGL).</doc>
			<ingroup>g_nodes</ingroup>
			<ingroup>g_multiAttributeNodes</ingroup>
			<ingroup>g_transformationNodes</ingroup>
		</doxygen>
		<sf name="plane" doc="Specifies the clipping plane.">
			<type name="Plane" namespace="vgm" default="vgm::Vec3f(1.f, 0.f, 0.f), 0.f "></type>
		</sf>
		<of name="on" doc="Specifies if the clipping plane is enabled or disabled.">
			<type name="bool" default="true"/>
		</of>
	</node>


	<node name = "CullFace" inherits="SingleAttribute" >
		<doxygen>
			<docBrief>Cull face facets definition node</docBrief>
			<doc>The CullFace node specifies whether front-facing and/or back-facing facets can be culled.</doc>
			<doc>Facets include triangles, quadrilaterals, polygons and rectangles.</doc>
			<doc>FrontFace node specifies which of the clockwise and counterclockwise facets are front-facing and back-facing.</doc>
			<doc>See vgd::node::FrontFace.</doc>
			<ingroup>g_nodes</ingroup>
			<ingroup>g_singleAttributeNodes</ingroup>
			<ingroup>g_propertiesNodes</ingroup>
		</doxygen>

		<sf name="mode" doc="Specifies whether front-facing and/or back-facing facets can be culled.">
			<type name="enum">
				<enum default="DISABLED">
					<value name="DISABLED" doc="Facet culling is disabled"/>
					<value name="BACK" doc="Back-facing facets are culled"/>
					<value name="FRONT" doc="Front-facing facets are culled"/>
					<value name="FRONT_AND_BACK" doc="Front-facing and back-facing facets are culled"/>
				</enum>
			</type>
		</sf>
	</node>


	<node name = "DepthOfField" inherits = "SingleAttribute" >
		<doxygen>
			<docBrief>Built-in post-processing effect depth of field</docBrief>
			<doc>Real camera lenses, due to their physical properties, blurs parts of a scene at certain depths, while maintaining sharpness in others areas.</doc>
			<doc>This built-in post-processing effect simulates a thin lens camera</doc>
			<ingroup>g_nodes</ingroup>
			<ingroup>g_singleAttributeNodes</ingroup>
			<ingroup>g_frameBufferNodes</ingroup>
		</doxygen>

		<sf name="cameraModel" doc="Sets the camera model.">
			<type name="enum">
				<enum default="THIN_LENS">
					<value name="PINHOLE" doc="todo"/>
					<value name="THIN_LENS" doc="todo"/>
				</enum>
			</type>
		</sf>

		<sf name="focus" doc="Sets the focal distance. Objects on the focal plane (i.e. at focus distance) are in perfect focus.">
			<type name = "float" default = "0.f"></type>
		</sf>

		<sf name="focusToFar" doc="Sets the distance from focus to far. Must be greater than zero.">
			<type name = "float" default = "1.f"></type>
		</sf>

		<sf name="focusToNear" doc="Sets the distance from focus to near. Must be greater than zero.">
			<type name = "float" default = "1.f"></type>
		</sf>

		<sf name="farMaximumBlurriness" doc="Sets the maximum blurriness for object(s) in [focus, far]. 0 means no blur at all. 1 means maximum blurriness.">
			<type name = "float" default = "0.5f"></type>
		</sf>

		<sf name="nearMaximumBlurriness" doc="Sets the maximum blurriness for object(s) in [near, focus]. 0 means no blur at all. 1 means maximum blurriness.">
			<type name = "float" default = "0.5f"></type>
		</sf>

		<sf name="sampling" doc="Sets the number of samples (must be 1, 2, 3, 4, 5, 6, 7 or 8).">
			<type name = "int" default = "8"></type>
		</sf>

	</node>


	<node name = "Fluid" inherits = "Shape" >
		<doxygen>
			<docBrief>Fluid allow the simulation of liquids</docBrief>
			<doc>Liquids are simulated using several height maps (sceneHeightMap computed from \c scene, fluidHeightMap containing height of the fluid).</doc>
			<doc>A tessellated quad with displacement mapping is used for the rendering.</doc>
			<ingroup>g_nodes</ingroup>
			<ingroup>g_shapeNodes</ingroup>
			<ingroup>g_propertiesNodes</ingroup>
		</doxygen>

		<sf name="scene" doc="Specifies the root of the scene graph used by the fluid simulation.">
			<type name = "NodeWkp" namespace = "vgd::node"></type>
		</sf>

		<sf name="gravity" doc="Specifies the direction of the gravity (the first three components) and the intensity (the last component).">
			<type name="Vec4f" namespace="vgm" default = "0.f, -1.f, 0.f, 9.8f"></type>
		</sf>


		<sf name="heightMapSize" doc="Specifies the size of the textures used to store scene and fluid height map.">
			<type name="Vec2i" namespace="vgm" default = "256, 256"></type>
		</sf>

		<sf name="simulationPass0" doc="Specifies the first stage of the simulation.">
			<type name="string" namespace="std" default = ""></type>
		</sf>

		<sf name="simulationPass1" doc="Specifies the second stage of the simulation.">
			<type name="string" namespace="std" default = ""></type>
		</sf>

		<sf name="cellSize" doc="@todo">
			<type name="float" default="1.0"></type>
		</sf>
		<sf name="css" doc="@todo">
			<type name="float" default="1.0"></type>
		</sf>
		<sf name="timeStep" doc="@todo">
			<type name="float" default="0.1"></type>
		</sf>
		<sf name="damping" doc="@todo">
			<type name="float" default="0.8"></type>
		</sf>

		<sf name="thickness" doc="fluid thickness factor (only visual)">
			<type name="float" default="1.0"></type>
		</sf>
		<sf name="opacity" doc="@todo">
			<type name="float" default="0.6"></type>
		</sf>

		<mf name="emittersOrDrainers" doc="Specifies the position (x, y, z), and properties (radius and intensity) of each fluid emitter/drainer. Actually, the maximum number of emitters/drainers is 4.">
			<type name="Vec5f" namespace="vgm" default = "0.f, 0.f, 0.f, 0.f, 0.f"></type>
		</mf>


-		<sf name="requestFeedback" doc="True to request a feedback in field fluidPositionFeedback during the next rendering. This field is automatically reset to false after the completion of the feedback.">
			<type name="bool" default = "false"></type>
		</sf>

		<sf name="feedbackInformations" doc="@todo">
			<type name="Vec5f" namespace="vgm" default = "0.f, 0.f, 0.f, 0.f, 0.f"></type>
		</sf>

		<sf name="feedbackInformationsBis" doc="@todo">
			<type name="MatrixR" namespace="vgm" default = "vgm::MatrixR::getIdentity()"></type>
		</sf>

		<sf name="fluidPositionFeedback" doc="@todo">
			<type name = "IImageShp" namespace = "vgd::basic"></type>
		</sf>


		<includehpp>vgd/include/vgd/node/Fluid.hpp</includehpp>
		<includecpp>vgd/src/node/Fluid.cpp</includecpp>
	</node>



	<node name = "LayerPlan" inherits = "MultiAttribute" > <!-- @todo not a real MultiAttribute -->
		<doxygen>
			<docBrief>Defines a single layer plan (overlay or underlay).</docBrief>
			<doc>This node defines a layer plan that could be displayed just before the rendering (UNDERLAY) or just after (OVERLAY).</doc>
			<doc>In fact, the behavior depends of its position in the scene graph. It could even be displayed at any time during the rendering.</doc>
			<doc>@todo More advanced transformation (a field \c matrixTransform)</doc>
			<doc>@todo Support multiple layer planes at the same time and do rendering in one pass. => This class should be a multiattribute.</doc>
			<ingroup>g_nodes</ingroup>
			<ingroup>g_singleAttributeNodes</ingroup>
			<ingroup>g_shapeNodes</ingroup>
			<ingroup>g_layerplan</ingroup>
		</doxygen>

		<df name = "image" linkToFields="image"></df>

		<sf name = "position" doc="Sets the position of the layer plan in normalized window coordinates system. @see g_coordinatesSystem">
			<type name="Vec2f" namespace="vgm" default = "0.f, 0.f"></type>
		</sf>

		<sf name = "size" doc="Sets the size of the layer plan in normalized windows coordinates system.@see g_coordinatesSystem\n - A size equal to (1, 1) means that the layer plan must fit the whole window. - A size equal to (0.5, 1) means that the layer plan fit in the half window width and fit in the whole height of the window.">
			<type name="Vec2f" namespace="vgm" default ="1.f, 1.f"></type>
		</sf>

		<sf name = "image" doc="Determines the image to display in the layer plan. You can set multiple times this field, but only if all successive images have the same format. The data and size of the image can changed, but that's all.">
			<type name = "IImageShp" namespace = "vgd::basic"></type>
		</sf>

		<sf name = "alphaScale" doc="Sets the alphaScale value used at each image update to multiply the alpha component of \c iimage by the scale factor. After this operation, the alpha component is clamped to the range [0, 1].">
			<type name = "float" default = "1.f"></type>
		</sf>
	</node>


	<!-- @todo generalizes for all MultiAttribute -->
	<!-- @todo Underlay -->
	<node name= "Overlay" inherits = "LayerPlan">
		<doxygen>
			<docBrief>Specialized layer plan drawn at the end of the rendering.</docBrief>
			<doc>This node behaves as a MultiAttribute node with an automatic index.</doc>
			<doc>Unlike LayerPlan, the rendering is deferred at the end of the rendering pipeline.</doc>
			<ingroup>g_nodes</ingroup>
			<ingroup>g_singleAttributeNodes</ingroup>
			<ingroup>g_multiAttributeNodes</ingroup>
			<ingroup>g_autoMultiAttributeNodes</ingroup>
			<ingroup>g_shapeNodes</ingroup>
			<ingroup>g_layerplan</ingroup>
		</doxygen>
	</node>


	<node name = "DirectionalLight" inherits = "Light" >
		<doxygen>
			<docBrief>Node representing a directional light source.</docBrief>
			<doc>This node defines a directional light source that illuminates along rays parallel to a given 3-dimensional vector.</doc>
			<ingroup>g_nodes</ingroup>
			<ingroup>g_multiAttributeNodes</ingroup>
			<ingroup>g_coloringAndLightingNodes</ingroup>
		</doxygen>

		<of name="direction" doc="Direction of the light.">
			<type name = "Vec3f" namespace="vgm" default="0.f, 0.f, -1.f"></type>
		</of>
	</node>


	<node name = "FrameBuffer" inherits = "SingleAttribute" >
		<doxygen>
			<docBrief>Node representing the current framebuffer.</docBrief>
			<doc>This node specifies which color(s)/depth/stencil buffers are to be drawn into.</doc>
			<ingroup>g_nodes</ingroup>
			<ingroup>g_singleAttributeNodes</ingroup>
			<ingroup>g_frameBufferNodes</ingroup>
		</doxygen>
	</node>


	<node name = "FrontFace" inherits = "SingleAttribute" >
		<doxygen>
			<docBrief>Front face polygons definition node</docBrief>
			<doc>The FrontFace node specifies if polygons are in clockwise winding in window coordinates, or counterclockwise winding in window coordinates, are taken to be front-facing.</doc>
			<ingroup>g_nodes</ingroup>
			<ingroup>g_singleAttributeNodes</ingroup>
			<ingroup>g_propertiesNodes</ingroup>
		</doxygen>
		<sf name="orientation" doc="Specifies if front facing polygons are clockwise (CW) or conterclockwise (CCW)">
			<type name="enum">
				<enum default="CCW">
					<value name="CCW" doc="(C)ounter-(C)lock(W)ise ordering"/>
					<value name="CW" doc="(C)lock(W)ise ordering"/>
				</enum>
			</type>
		</sf>
	</node>


	<node name = "Light" inherits = "MultiAttribute" abstract = "true" >
		<doxygen>
			<docBrief>Abstract base class for all light source nodes</docBrief>
			<doc>Light is the abstract base class for all light nodes. A light node defines an illumination</doc>
			<doc>source that may affect subsequent shapes in the scene graph, depending on the current lighting</doc>
			<doc>style. Light sources are affected by the current transformation. A light node under a separator</doc>
			<doc>does not affect any objects outside that separator.</doc>
			<doc>@remarks The maximum number of lights is equal at least to 8 in OpenGL and DirectX. Feel free to use up to 8 lights. @todo Removes this limits</doc>
			<doc>@todo Support for attenuation</doc>
			<doc>@todo High-level method for changing intensity of color.</doc>
			<ingroup>g_abstractNodes</ingroup>
		</doxygen>
		<of name="on" doc="Determines whether the source is active or inactive. When inactive, the source does not illuminate at all. Set to true to switch on the light, false to switch off the light.">
			<type name="bool" default="false"></type>
		</of>
		<of name="ambient" doc="Ambient intensity of the light.">
			<type name="Vec4f" namespace="vgm" default="0.f, 0.f, 0.f, 0.f"></type>
		</of>
		<of name="diffuse" doc="Diffuse intensity of the light.">
			<type name="Vec4f" namespace="vgm" default="1.f, 1.f, 1.f, 0.f"></type>
		</of>
		<of name="specular" doc="Specular intensity of the light.">
			<type name="Vec4f" namespace="vgm" default="1.f, 1.f, 1.f, 0.f"></type>
		</of>

		<sf name="castShadow" doc="Indicating that this light casts a shadow.">
			<type name="bool" default="false"></type>
		</sf>

		<includehpp>vgd/include/vgd/node/Light.hpp</includehpp>
		<includecpp>vgd/src/node/Light.cpp</includecpp>
	</node>


	<!-- TODO Split this node => ShadowStyle/Properties -->
	<node name = "LightModel" inherits = "SingleAttribute" >
		<doxygen>
			<docBrief>Lighting model node</docBrief>
			<doc>This node specifies current lighting mode (off/standard per vertex lighting/standard per pixel lighting) and some options of the lighting model.</doc>
			<ingroup>g_nodes</ingroup>
			<ingroup>g_singleAttributeNodes</ingroup>
			<ingroup>g_coloringAndLightingNodes</ingroup>
		</doxygen>

		<of name="model" doc="Sets the lighting model to LIGHTING_OFF, STANDARD_PER_VERTEX or STANDARD_PER_PIXEL.">
			<type name="enum">
				<enum default="STANDARD_PER_VERTEX">
					<value name="LIGHTING_OFF"			doc="No lighting"/>
					<value name="STANDARD_PER_VERTEX"	doc="Lighting is computed per vertex"/>
					<value name="STANDARD_PER_PIXEL"	doc="Lighting is computed per pixel"/>
				</enum>
			</type>
		</of>

		<of name="ambient" doc="Sets the ambient RGBA intensity of the entire scene.">
			<type name="Vec4f" namespace="vgm" default="0.2f, 0.2f, 0.2f, 0.0f"></type>
		</of>

		<of name="viewer" doc="Specifies how specular reflection angles are computed. Possible values :
- AT_INFINITY specular reflections are computed from the origin of the eye coordinate system.
- AT_EYE specular reflection angles take the view direction to be parallel to and in the direction of the -z axis, regardless of the location of the vertex in eye coordinates.">
			<type name="enum">
				<enum default="AT_INFINITY">
					<value name="AT_INFINITY"	doc="Specular reflections are computed from the origin of the eye coordinate system"/>
					<value name="AT_EYE"		doc="Specular reflection angles take the view direction to be parallel to and in the direction of the -z axis, regardless of the location of the vertex in eye coordinates"/>
				</enum>
			</type>
		</of>

		<of name="twoSided" doc="Specifies whether one- or two-sided lighting calculations are done for polygons and triangles.">
			<type name="bool" default="false"></type>
		</of>

		<of name="shadow" doc="Specifies the algorithm used to compute shadow.">
			<type name="enum">
				<enum default="SHADOW_OFF">
					<value name="SHADOW_OFF"			doc="Shadows are not computed"/>
					<value name="SHADOW_MAPPING"		doc="Shadows are computed using shadow mapping algorithm"/>
					<value name="SHADOW_MAPPING_4U"		doc="Four uniform samples"/>
					<value name="SHADOW_MAPPING_4UM"	doc="Four uniform samples"/>
					<value name="SHADOW_MAPPING_4DM"	doc="Four dithered samples"/>
					<value name="SHADOW_MAPPING_9U"		doc="Nine uniform samples"/>
					<value name="SHADOW_MAPPING_9UM"	doc="Nine unifrom samples"/>
					<value name="SHADOW_MAPPING_16U"	doc="Sixteen uniform samples"/>
					<value name="SHADOW_MAPPING_16UM"	doc="Sixteen unifrom samples"/>
					<value name="SHADOW_MAPPING_32U"	doc="Thirty two uniform samples"/>
					<value name="SHADOW_MAPPING_32UM"	doc="Thirty two uniform samples"/>
					<value name="SHADOW_MAPPING_64U"	doc="Sixty four uniform samples"/>
					<value name="SHADOW_MAPPING_64UM"	doc="Sixty four uniform samples"/>
					<!-- @todo custom -->
				</enum>
			</type>
		</of>

		<sf name="samplingSize" doc="">
			<type name="float" default="1.0"/>
		</sf>
		
		<of name="shadowMapSize" doc="Specifies the size of the shadow map">
			<type name="enum">
				<enum default="MEDIUM">
					<value name="LOW"		doc="Low resolution shadow map"/>
					<value name="MEDIUM"	doc="Medium resolution shadow map"/>
					<value name="HIGH"		doc="High resolution shadow map"/>
					<value name="VERY_HIGH"	doc="Very high resolution shadow map"/>
				</enum>
			</type>
		</of>

		<sf name="shadowMapType" doc="">
			<type name="enum">
				<enum default="INT32">
					<value name="INT16"		doc="see Texture.internalFormat documentation"/>
					<value name="INT24"		doc="see Texture.internalFormat documentation"/>
					<value name="INT32"		doc="see Texture.internalFormat documentation"/>
					<value name="FLOAT32"	doc="see Texture.internalFormat documentation"/>
				</enum>
			</type>
		</sf>

		<sf name="illuminationInShadow" doc="value=[0,1] : 0 full attenuation in shadow, 1 no attenuation in shadow">
			<type name="float" default="0.4f"></type>
		</sf>

		<sf name="shadowPolygonOffset" doc="">
			<type name="Vec2f" namespace="vgm" default="4.f, 16.f"></type>
		</sf>

		<of name="shadowFiltering" doc="Defines depth map hardware filtering (not the filtering done in shaders).">
			<type name="enum">
				<enum default="LINEAR">
					<value name="NEAREST"	doc=""/>
					<value name="LINEAR"	doc=""/>
				</enum>
			</type>
		</of>

		<sf name="option0" doc="">
			<type name="enum">
				<enum default="CHOICE0">
					<value name="CHOICE0" doc=""/>
					<value name="CHOICE1" doc=""/>
					<value name="CHOICE2" doc=""/>
					<value name="CHOICE3" doc=""/>
					<value name="CHOICE4" doc=""/>
				</enum>
			</type>
		</sf>

		<sf name="option1" doc="">
			<type name="bool" default="false"/>
		</sf>

		<sf name="option2" doc="">
			<type name="bool" default="false"/>
		</sf>

<!-- EngineProperty/properties/style -->
		<sf name="ignorePostProcessing" doc="true to ignore the whole post-processing stage, false to do post-processing stage if at least one PostProcessing node is defined.">
			<type name="bool" default="false"/>
		</sf>
	</node>


	<node name = "Material" inherits = "SingleAttribute" >
		<doxygen>
			<docBrief>Surface material definition node</docBrief>
			<doc>The Material node specifies current surface material properties for all subsequent shapes nodes</doc>
			<doc> and is used by the lighting equations during rendering.</doc>
			<doc>The field \c opacity (alpha value) is used in the lighting computation only for the diffuse alpha component.</doc>
			<doc>The field \c transparency is not optional because it is used by others fields (in OpenGL ambient and others use 4 floats).</doc>
			<ingroup>g_nodes</ingroup>
			<ingroup>g_singleAttributeNodes</ingroup>
			<ingroup>g_coloringAndLightingNodes</ingroup>
		</doxygen>

		<sf name="opacity" doc="Sets opacity from 1.0 for being completely opaque until 0.0 for being completely transparent.">
			<type name="float" default="1.f"></type>
		</sf>

		<of name="ambient" doc="Ambient color of the surface.">
			<type name="Vec3f" namespace="vgm" default="0.2f, 0.2f, 0.2f"/>
		</of>

		<of name="diffuse" doc="Diffuse color of the surface.">
			<type name="Vec3f" namespace="vgm" default="0.8f, 0.8f, 0.8f"/>
		</of>

		<of name="specular" doc="Specular color of the surface.">
			<type name="Vec3f" namespace="vgm" default="0.f, 0.f, 0.f"/>
		</of>

		<of name="emission" doc="Emmissive color of the surface.">
			<type name="Vec3f" namespace="vgm" default="0.f, 0.f, 0.f"/>
		</of>

		<of name="shininess" doc="Shininess coefficient of the surface. Values can range from 0.0 for no shininess (a diffuse surface) to 1.0 for maximum shininess (a highly polished surface).">
			<type name="float" default="0.f"></type>
		</of>

<!--		<of name="face" doc="Specifies which face(s) are being updated.">
			<type name="enum">
				<enum default="FRONT_AND_BACK">
					<value name="BACK" doc="Back-facing facets are updated"/>
					<value name="FRONT" doc="Front-facing facets are updated"/>
					<value name="FRONT_AND_BACK" doc="Front-facing and back-facing facets are updated"/>
				</enum>
			</type>
		</of>-->

		<includehpp>vgd/include/vgd/node/Material.hpp</includehpp>
		<includecpp>vgd/src/node/Material.cpp</includecpp>
<!--	<codehpp></codehpp> <codecpp></codecpp> -->
	</node>


	<node name = "MultipleInstances" inherits = "Shape">
		<doxygen>
			<docBrief>Instanciated the same object multiple times in the scene</docBrief>
			<doc>The object, defined by the shape field, is instanciated once per matrix available in the field named matrix.</doc>
			<doc>The matrix is concatenated to the current geometrical transformation matrix.</doc>
			<doc>This allows the user to put multiple copies of the same data in different locations easily and efficiently.</doc>
			<doc>@todo really implements vgd::node::IBoundingBox interface. useful ?</doc>
			<ingroup>g_nodes</ingroup>
			<ingroup>g_shapeNodes</ingroup>
			<ingroup>g_transformationNodes</ingroup>
		</doxygen>

		<sf name = "shape" doc = "The object to instanciate multiple times.">
			<type name = "NodeShp" namespace = "vgd::node"></type>
		</sf>

		<mf name = "matrix" doc = "The array of matrices used to transform the object in different locations">
			<type name = "MatrixR" namespace="vgm"></type>
		</mf>

		<includehpp>vgd/include/vgd/node/MultipleInstances.hpp</includehpp>
		<includecpp>vgd/src/node/MultipleInstances.cpp</includecpp>
	</node>


<!--@todo debug blit when scaleDownUp -->
	<node name = "OutputBufferProperty" inherits = "MultiAttribute">
		<doxygen>
			<docBrief>Definition of the size, format, type and output command of an output buffer</docBrief>
			<doc>@todo</doc>
			<ingroup>g_nodes</ingroup>
			<ingroup>g_multiAttributeNodes</ingroup>
			<ingroup>g_autoMultiAttributeNodes</ingroup>
			<ingroup>g_frameBufferNodes</ingroup>

			<ingroup>g_postProcessing</ingroup>
		</doxygen>

		<sf name = "sizeSemantic" doc = "Specifies the semantic of the size field.">
			<type name = "enum">
				<enum default="SCALE_FACTOR">
					<value name= "SCALE_FACTOR"	doc="The width of the output buffer is computed using the width of the drawing surface area scaled by the first component of size field (same for height and second component)"/>
					<value name= "PIXEL_SIZE"	doc="The size field specifies the size of the output buffer in pixels."/>
				</enum>
			</type>
		</sf>

		<sf name = "size" doc = "Specifies the size of the output buffer (in pixel or scale factors). See sizeSemantic field for more informations.">
			<type name = "Vec2f" namespace="vgm" default="1.f, 1.f"></type>
		</sf>

		<sf name = "format" doc = "Specifies the format used by the buffer.">
			<type name = "enum">
				<enum default="RGB">
					<value name="RGB" doc="@todo"/>
					<value name="RGBA" doc="@todo"/>
					<value name="LUMINANCE" doc="@todo"/>
					<value name="LUMINANCE_ALPHA" doc="@todo"/>
					<value name="LUMINANCE_FOR_DEPTH" doc="if type is INTEGER, then DEPTH_COMPONENT_24 is used."/>
				</enum>
			</type>
		</sf>

<!-- @todo INTEGER8, 16, 24, 32 -->
		<sf name = "type" doc = "Specifies the type used by the buffer.">
			<type name = "enum">
				<enum default = "INTEGER">
					<value name="INTEGER" doc="@todo"/>
					<value name="FLOAT16" doc="@todo"/>
					<value name="FLOAT32" doc="@todo"/>
				</enum>
			</type>
		</sf>

		<sf name = "current" doc = "Specifies if this output buffer must be used for drawing by default. See vgd::node::OutputBuffer to alter this initial state.">
			<type name = "bool" default = "true"></type>
		</sf>


		<sf name = "command" doc = "Specifies the pre-defined assign command execute by the fragment program.">
			<type name = "enum">
				<enum default = "COLOR">
					<value name="COLOR" doc="@todo"/>
					<value name="NORMAL" doc="@todo"/>
					<value name="POSITION" doc="@todo"/>
					<value name="DEPTH" doc="@todo"/>
					<value name="LINEAR_DEPTH" doc="@todo"/>
					<value name="CUSTOM" doc="@todo"/>
				</enum>
			</type>
		</sf>

		<sf name = "customDeclaration" doc = "Specifies the declaration to copy at the beginning of the fragment program when command field is CUSTOM.">
			<type name = "string" namespace = "std"></type>
		</sf>

		<sf name = "customCommand" doc = "Specifies the assign command execute by the fragment program. Example : color.rgba; or vec4( clamp(color.rgb, 0.0, 1.0), ecPosition.z ); or computeMyCustomValue( ecPosition );">
			<type name = "string" namespace = "std"></type>
		</sf>

	</node>


	<node name = "OutputBuffers" inherits = "SingleAttribute">
		<doxygen>
			<docBrief>Select which buffers to use for drawing</docBrief>
			<doc>This node affect subsequent shapes in the scene graph.</doc>
			<doc>But if this node is under a separator, it does not affect any objects outside that separator.</doc>
			<ingroup>g_nodes</ingroup>
			<ingroup>g_singleAttributeNodes</ingroup>
			<ingroup>g_frameBufferNodes</ingroup>

			<ingroup>g_postProcessing</ingroup>
		</doxygen>

		<mf name = "current" doc = "Specifies the buffers used for rendering. The selection is done using multi-attribute index of OutputBufferProperty nodes.\n @remark The same index may not appear more then once.">
			<type name="int"></type>
		</mf>

		<includehpp>vgd/include/vgd/node/OutputBuffers.hpp</includehpp>
		<includecpp>vgd/src/node/OutputBuffers.cpp</includecpp>
	</node>


	<node name = "PointLight" inherits = "Light" >
		<doxygen>
			<docBrief>Node representing a point light source.</docBrief>
			<doc>A point source illuminates equally in all directions. It is omni-directional.</doc>
			<doc>All shape nodes that come after this light in the scene graph are illuminated by this light.</doc>
			<doc>The light's location is affected by the current geometrical transformation.</doc>
			<ingroup>g_nodes</ingroup>
			<ingroup>g_multiAttributeNodes</ingroup>
			<ingroup>g_coloringAndLightingNodes</ingroup>
		</doxygen>

		<of name = "position" doc = "Location of the light source.">
			<type name = "Vec3f" namespace = "vgm" default = "0.f, 0.f, 1.f"></type>
		</of>
	</node>


	<node name = "PointStyle" inherits="SingleAttribute" >
		<doxygen>
			<docBrief>Defines the style to use when rendering points</docBrief>
			<ingroup>g_nodes</ingroup>
			<ingroup>g_singleAttributeNodes</ingroup>
			<ingroup>g_propertiesNodes</ingroup>
		</doxygen>
		<of name="size" doc="Specifies the rasterized diameter of both aliased and antialiased points">
			<type name = "float" default = "1.f"></type>
		</of>

		<of name="distanceAttenuation" doc="a vector of three floating-point values that specify the coefficients used for scaling the computed point size. The default values are (1 0 0).">
			<type name = "Vec3f" namespace="vgm" default = "1.f, 0.f, 0.f"></type>
		</of>

		<of name="smooth" doc="If enabled, draw antialiased points, otherwise draw aliased points. Ignored when point sprite is enabled.">
			<type name = "bool" default = "false"></type>
		</of>

		<of name="pointSprite" doc="See GL_ARB_point_sprite extension for details (http://oss.sgi.com/projects/ogl-sample/registry/ARB/point_sprite.txt).">
			<type name = "bool" default = "false"></type>
		</of>
	</node>


	<node name = "PostProcessing" inherits = "MultiAttribute" >
		<doxygen>
			<docBrief>A single stage of a post-processing pipeline.</docBrief>
			<doc>This node defines a single stage of a post-processing pipeline, i.e. a \c filter function applied on each pixel of the drawing surface</doc>
			<doc>with up to 3 input buffers, several parameters and one output buffer.</doc>
			<doc>Typical use-case of post-processing pipeline is to apply effect to the the previously rendered scene like depth of field, bloom and so on.</doc>
			<ingroup>g_nodes</ingroup>
			<ingroup>g_multiAttributeNodes</ingroup>
			<ingroup>g_autoMultiAttributeNodes</ingroup>
			<ingroup>g_texturingNodes</ingroup>
			<ingroup>g_frameBufferNodes</ingroup>

			<ingroup>g_postProcessing</ingroup>
		</doxygen>

		<sf name = "filter" doc = "Specifies the filter to apply to the input buffers.">
			<type name = "enum">
				<enum default="NO_FILTER">
					<value name="IDENTITY"	doc="Identity filter, so the resulting image is the input image."/>

					<value name="COLOR_TO_MONOCHROME" doc="Converts colored value to black and white"/>
					<value name="COLOR_TO_SEPIA" doc="Converts colored value to sepia.\n Sets desaturate parameter(default 0.5f, min 0.0f, max 1.0f) into param4f0[0]. Sets toning parameter ( default 1.f, min 0.0f, max 1.0f) into param4f0[1]."/>
					<value name="COLOR_INVERSE" doc="Inverts the colored value"/>

					<value name="SCALE_AND_BIAS" doc="Each of the color components is multiplied by a scale factor, then added to a bias factor using the following formula : output = input0 * param4f0 + param4f1."/>

					<value name="BLUR_HORIZ" doc="Blurs an image horizontally using weights that follow a gaussian distribution."/>
					<value name="BLUR_VERT" doc="Blurs an image vertically using weights that follow a gaussian distribution."/>
					<value name="BLOOM_HORIZ" doc="Amplifies and blurs an image horizontally using weights that follow a gaussian distribution. Bloom scale could be specify using param1f0."/>
					<value name="BLOOM_VERT" doc="Amplifies and blurs an image vertically using weights that follow a gaussian distribution. Bloom scale could be specify using param1f0."/>

					<value name="COLOR_EDGE_DETECT" doc="Detects edges and highlights them"/>

					<value name="DOWN_FILTER4" doc="Scales images down 4 times with a high-pass filter"/>
					<value name="UP_FILTER4" doc="Scales images up 4 times"/>

<!--					<value name="NORMAL_EDGE_DETECT" doc="Detects edges and highlights them (using NORMAL buffer)"/> -->

					<value name="OVER" doc="Composes two images using an over filter. The input0 source is composited over the input1 source. @todo uses alpha instead black to decide composition"/>
					<value name="ADD" doc="Combines two images into one using the following formula : image1 + image2"/>
					<value name="SUB" doc="Combines two images into one using the following formula : image1 - image2"/>

					<value name="MIX_AND_SCALE" doc="Combines two images into one by blending them linearly using the following formula : image1 * (1-a) + image2 * a with a = param4f0[0].\n Then the resulting image is multiplied by a scale factor : previousComputation *=scale with scale = param4f0[1]"/>
					<value name="ALPHAMIX_AND_SCALE" doc="Combines two images into one by blending them linearly using the following formula : image1 * (1-a) + image2 * a with a = image2.a\n Then the resulting image is multiplied by a scale factor : previousComputation *=scale with scale = param1f0. The alpha channel of the output is image2.a"/>
					<value name="COMBINE2_AND_SCALE" doc="Combines two images into one by blending them linearly using the following formula : image1 * a + image2 * b with a = param4f0[0] and b = param4f0[1].\n Then the resulting image is multiplied by a scale factor : previousComputation *=scale with scale = param4f0[2]"/>
					<value name="COMBINE3_AND_SCALE" doc="Combines three images into one by blending them linearly using the following formula : image1 * a + image2 * b + image3 * c with a = param4f0[0], b = param4f0[1] and c = param4f0[2].\n Then the resulting image is multiplied by a scale factor : previousComputation *=scale with scale = param4f0[3]"/>

					<value name="NO_FILTER"	doc="No filter is applied"/>

					<value name="CUSTOM_FILTER" doc="The filter defined by field customFilterDefinition is applied using field customFilterApply."/>
				</enum>
			</type>
		</sf>

		<sf name = "customFilterDefinition" doc = "Specifies the code implementing the filter.">
			<type name="string" namespace="std"/>
		</sf>

		<sf name = "customFilterApply" doc = "Specifies the code calling the filter defined by customFilterDefinition.">
			<type name="string" namespace="std"/>
		</sf>

<!-- TODO rename PREVIOUS0 => TMP0 -->
<!-- TODO enum for input1, input2 should be the same as input0 => specify enum at node level -->
		<sf name = "input0" doc = "Specifies the first input buffer used by the filter.">
			<type name = "enum">
				<enum default = "PREVIOUS0">
					<value name="OUTPUT_BUFFER0" doc=""/>
					<value name="OUTPUT_BUFFER1" doc=""/>
					<value name="OUTPUT_BUFFER2" doc=""/>
					<value name="OUTPUT_BUFFER3" doc=""/>
					<value name="OUTPUT_BUFFER4" doc=""/>
					<value name="OUTPUT_BUFFER5" doc=""/>
					<value name="OUTPUT_BUFFER6" doc=""/>
					<value name="OUTPUT_BUFFER7" doc=""/>
					<value name="TEXTURE0" doc=""/>
					<value name="PREVIOUS0" doc=""/>
<!-- @todo 			<value name="PREVIOUS1" doc=""/> -->
					<value name="NONE" doc=""/>
				</enum>
			</type>
		</sf>

		<sf name = "input1" doc = "Specifies the second input buffer used by the filter.">
			<type name = "enum">
				<enum default = "INPUT1_NONE">
					<value name="INPUT1_OUTPUT_BUFFER0" doc=""/>
					<value name="INPUT1_OUTPUT_BUFFER1" doc=""/>
					<value name="INPUT1_OUTPUT_BUFFER2" doc=""/>
					<value name="INPUT1_OUTPUT_BUFFER3" doc=""/>
					<value name="INPUT1_OUTPUT_BUFFER4" doc=""/>
					<value name="INPUT1_OUTPUT_BUFFER5" doc=""/>
					<value name="INPUT1_OUTPUT_BUFFER6" doc=""/>
					<value name="INPUT1_OUTPUT_BUFFER7" doc=""/>
					<value name="INPUT1_TEXTURE0" doc=""/>
					<value name="INPUT1_PREVIOUS0" doc=""/>
<!-- @todo 			<value name="INPUT1_PREVIOUS1" doc=""/> -->
					<value name="INPUT1_NONE" doc=""/>
				</enum>
			</type>
		</sf>

		<sf name = "input2" doc = "Specifies the third input buffer used by the filter.">
			<type name = "enum">
				<enum default = "INPUT2_NONE">
					<value name="INPUT2_OUTPUT_BUFFER0" doc=""/>
					<value name="INPUT2_OUTPUT_BUFFER1" doc=""/>
					<value name="INPUT2_OUTPUT_BUFFER2" doc=""/>
					<value name="INPUT2_OUTPUT_BUFFER3" doc=""/>
					<value name="INPUT2_OUTPUT_BUFFER4" doc=""/>
					<value name="INPUT2_OUTPUT_BUFFER5" doc=""/>
					<value name="INPUT2_OUTPUT_BUFFER6" doc=""/>
					<value name="INPUT2_OUTPUT_BUFFER7" doc=""/>
					<value name="INPUT2_TEXTURE0" doc=""/>
					<value name="INPUT2_PREVIOUS0" doc=""/>
<!-- @todo 			<value name="INPUT2_PREVIOUS1" doc=""/> -->
					<value name="INPUT2_NONE" doc=""/>
				</enum>
			</type>
		</sf>


		<of name="texture0" doc = "Specifies the texture available through input buffer used by the filter when TEXTURE0 is specified. Must be a Texture2D node.">
			<type name = "NodeWkp" namespace = "vgd::node"></type><!-- todo TextureWkp -->
		</of>


		<of name = "param1f0" doc = "Specifies the first 1f parameter used by the filter.">
			<type name = "float" default = "0.0"></type>
		</of>

		<of name = "param1f1" doc = "Specifies the second 1f parameter used by the filter.">
			<type name = "float" default = "0.0"></type>
		</of>

		<of name = "param4f0" doc = "Specifies the first 4f parameter used by the filter.">
			<type name = "Vec4f" namespace = "vgm" default = "0.0, 0.0, 0.0, 0.0"></type>
		</of>

		<of name = "param4f1" doc = "Specifies the second 4f parameter used by the filter.">
			<type name = "Vec4f" namespace = "vgm" default = "0.0, 0.0, 0.0, 0.0"></type>
		</of>

		<of name = "param4x4f0" doc = "Specifies the first 4x4f parameter used by the filter.">
			<type name = "MatrixR" namespace = "vgm" default = "vgm::MatrixR::getIdentity()"></type>
		</of>

		<sf name ="output" doc = "Specifices the output buffer used by the filter.">
			<type name = "enum">
				<enum default = "OUTPUT_TMP0">
					<value name="OUTPUT_TMP0" doc= "Post-processing internal buffer."/>
					<!--<value name="OUTPUT_TMP1" doc=""/> @todo re-enables-->
					<value name="OUTPUT_OUTPUT_BUFFER0" doc=""/>
					<value name="OUTPUT_OUTPUT_BUFFER1" doc=""/>
					<value name="OUTPUT_OUTPUT_BUFFER2" doc=""/>
					<value name="OUTPUT_OUTPUT_BUFFER3" doc=""/>
					<value name="OUTPUT_OUTPUT_BUFFER4" doc=""/>
					<value name="OUTPUT_OUTPUT_BUFFER5" doc=""/>
					<value name="OUTPUT_OUTPUT_BUFFER6" doc=""/>
					<value name="OUTPUT_OUTPUT_BUFFER7" doc=""/>
-				</enum>
			</type>
		</sf>

<!-- convolution filter and param [] -->
<!-- filter0, filter1, filter2 -->
<!-- ouput0, output1.... -->
	</node>


	<node name = "SpotLight" inherits = "PointLight" >
		<doxygen>
			<docBrief>Node representing a spotlight source.</docBrief>
			<doc>This node defines a spotlight style light source.</doc>
			<doc>A spotlight is placed at a fixed \c position in 3-space and illuminates in a cone along a particular \c direction.</doc>
			<doc>The illumination is within a cone whose angle is given by the \c cutOffAngle field.</doc>
			<doc>The intensity of the illumination drops off exponentially as a ray of light diverges from this direction toward the edges of the cone.</doc>
			<doc>The rate of drop-off and the angle of the cone are controlled by the \c dropOffRate and \c cutOffAngle fields.</doc>
			<doc>All shape nodes that come after this light in the scene graph are illuminated by this light.</doc>
			<doc>The light's location is affected by the current geometrical transformation.</doc>
			<ingroup>g_nodes</ingroup>
			<ingroup>g_multiAttributeNodes</ingroup>
			<ingroup>g_coloringAndLightingNodes</ingroup>
		</doxygen>

		<of name = "direction" doc = "The direction (center axis of cone) of the light in homogeneous object coordinates.">
			<type name = "Vec3f" namespace = "vgm" default = "0.f, 0.f, -1.f"></type>
		</of>

		<of name = "cutOffAngle" doc = "The angle (in degree) outside of which intensity is zero, measured from the center axis of the cone to an edge. This value must be inside [0, 90] or be equal to 180 (like PointLight node).">
			<type name = "float" default = "90.f"></type>
		</of>

		<of name = "dropOffRate" doc = "Rate of intensity drop-off per change in angle from primary direction. 0 means constant intensity, 1 means very sharp drop-off.">
			<type name = "float" default = "0.f"></type>
		</of>
	</node>


<!--TEXTURE_GEN_MODE
	OBJECT_LINEAR, EYE_LINEAR, SPHERE_MAP, NORMAL_MAP, or REFLECTION_MAP -->

	<node name = "TexGen" inherits = "MultiAttribute" abstract = "true" >
		<doxygen>
			<docBrief>Abstract node to control the generation of texture coordinates S, T, R and Q.</docBrief>
			<ingroup>g_abstractNodes</ingroup>
		</doxygen>

		<sf name="on" doc="Specifies if the texture generation is enabled or disabled.">
			<type name="bool" default="true"/>
		</sf>
	</node>

	<node name = "TexGenEyeLinear" inherits = "TexGen" >
		<doxygen>
			<docBrief>Generating texture coordinates using eye linear function</docBrief>
			<doc>See OpenGL specification for details</doc>
			<ingroup>g_nodes</ingroup>
			<ingroup>g_multiAttributeNodes</ingroup>
			<ingroup>g_texturingNodes</ingroup>
		</doxygen>

		<of name = "parameters" doc = "" >
			<type name = "MatrixR" namespace = "vgm" default = "vgm::MatrixR::getIdentity()"></type>
		</of>
	</node>

<!-- improves doc tag -->
	<node name = "Texture" inherits = "MultiAttribute" abstract = "true" >
		<doxygen>
			<docBrief>Abstract texture mapping node</docBrief>
			<doc>This node defines texture parameters (wrapping, filter for minifying and magnification, mipmapping and function).</doc>
			<doc>Be carefull, data referenced by image must be available when texture is update.</doc>
			<doc>This node creates a a texture from the iimage interface. So image could be an image stored in memory (with vgd::basic::ImageInfo) or from a file (with vgd::basic::Image) or a cairo image (with vgCairo::ImageSurface)</doc>
			<doc>@remarks When The scene graph is evaluated by vgeGL, there are a size constraint one texture that you should keep in mind.\n</doc>
			<doc>When the image exceed the maximum allowable size for the texture, a temporary resized copy of the \c iimage(to the maximum of the texture size) is used for defining texture. This is not very fast. Be carefull.\n</doc>
			<doc>- Radeon 8500 could do 2048 x 2048 for 2D texturing, 512 x 512 x 512 for 3D texturing and 2048 for cube mapping.\n</doc>
			<doc>- GeForce 2 could do 2048 x 2048 for 2D texturing, 64 x 64 x 64 for 3D texturing and 512 for cube mapping.\n</doc>
			<doc>- GeForce 3 could do 4096 x 4096 for 2D texturing, 512 x 512 x 512 for 3D texturing and 4096 for cube mapping.\n</doc>
			<doc>- GeForce FX could do 4096 x 4096 for 2D texturing, 512 x 512 x 512 for 3D texturing and 4096 for cube mapping.\n</doc>
			<doc>- GeForce 8 could do  8192 x 8192 for 2D texturing, 2048 x 2048 x 2048 for 3D texturing and 8192 for cube mapping.\n</doc>
			<doc>@remarks If your OpenGL implementation does'nt support advanced texturing not limited to images with power-of-two dimensions, a temporary resized copy of the \c iimage is used for all wrapping modes except \c ONCE.\n</doc>
			<doc>@todo More docs\n</doc>
			<ingroup>g_abstractNodes</ingroup>
		</doxygen>

		<df name = "image" linkToFields="image"></df>
		<df name = "parameters" linkToFields="wrap filter mipmap usage"></df>

		<of name = "image" doc = "Determines the source of data used to created the texture. You can set multiple times this field, but only if all successive images have the same format. The data and size of the image can changed, but that's all.">
			<type name = "IImageShp" namespace = "vgd::basic"></type>
		</of>

<!-- @todo Declare a new enum here to be shared by several fields -->
<!-- @todo <of name = "wrapS" doc=""> </of> -->

		<paf name = "wrap" doc = "Sets the wrap parameter for texture coordinate S, T or R to either REPEAT, CLAMP, CLAMP_TO_EDGE, CLAMP_TO_BORDER, MIRRORED_REPEAT or ONCE. Initially, this field is set to REPEAT for S, T and R." >
			<type name="enum">
				<enum default="WRAP_S">
					<value name="WRAP_S" doc=""/>
					<value name="WRAP_T" doc=""/>
					<value name="WRAP_R" doc=""/>
				</enum>
			</type>
			<type name="enum">
				<enum default="REPEAT">
					<value name="REPEAT" doc=""/>
					<value name="CLAMP" doc=""/>
					<value name="CLAMP_TO_EDGE" doc=""/>
					<value name="CLAMP_TO_BORDER" doc=""/>
					<value name="MIRRORED_REPEAT" doc=""/>
					<value name="ONCE" doc="Don't set texture coordinates outside the interval [0.f, 1.f]"/>
				</enum>
			</type>
		</paf>

		<paf name = "filter" doc ="The texture minifying function (MIN_FILTER) is used whenever the pixel being textured maps to an area greater than one texture element. The texture magnification function (MAG_FILTER) is used when the pixel being textured maps to an area less than or equal to one texture element." >
			<type name="enum">
				<enum default="MAG_FILTER">
					<value name="MIN_FILTER" doc="Choose one value among NEAREST, LINEAR (default), NEAREST_MIPMAP_NEAREST, LINEAR_MIPMAP_NEAREST, NEAREST_MIPMAP_LINEAR, LINEAR_MIPMAP_LINEAR."/>
					<value name="MAG_FILTER" doc="Choose one value among NEAREST or LINEAR (default)."/>
				</enum>
			</type>
			<type name="enum">
				<enum default="LINEAR">
					<value name="NEAREST" doc=""/>
					<value name="LINEAR" doc=""/>
					<value name="NEAREST_MIPMAP_NEAREST" doc=""/>
					<value name="LINEAR_MIPMAP_NEAREST" doc=""/>
					<value name="NEAREST_MIPMAP_LINEAR" doc=""/>
					<value name="LINEAR_MIPMAP_LINEAR" doc=""/>
				</enum>
			</type>
		</paf>

		<of name = "mipmap" doc="Specifies if all levels of a mipmap array should be automatically updated when any modification to the image field (the base level of mipmap) is done." >
			<type name="bool" default="false"/>
		</of>

<!-- @todo Choose a value among FUN_REPLACE, FUN_MODULATE, FUN_DECAL, FUN_BLEND, FUN_ADD and FUN_COMBINE. -->
		<of name = "vertexFunction" doc="Vertex texturing function.">
			<type name="string" namespace="std"/>
		</of>

		<of name = "fragmentFunction" doc="Fragment texturing function." >
			<type name="string" namespace="std"/>
		</of>


		<sf name = "usage" doc="Indicating the expected usage pattern of the texture.">
			<type name="enum">
				<enum default = "IMAGE">
					<value name="IMAGE" doc="Simple image mapping"/>
					<value name="SHADOW" doc="Shadow mapping"/>
				</enum>
			</type>
		</sf>

		<sf name = "internalFormat" doc="Specifies the desired internal format used by the GPU.">
			<type name="enum">
				<enum default="AUTOMATIC">
					<value name="AUTOMATIC"	doc="Choosed automatically an internal format matching the image format used by the texture."/>
					<value name="DEPTH_COMPONENT_16" doc="a single component buffer used to store depth. A 16-bit integer is used to encode a texel."/>
					<value name="DEPTH_COMPONENT_24" doc="a single component buffer used to store depth. A 24-bit integer is used to encode a texel."/>
					<value name="DEPTH_COMPONENT_32" doc="a single component buffer used to store depth. A 32-bit integer is used to encode a texel."/>
					<value name="DEPTH_COMPONENT_32F" doc="a single component buffer used to store depth. A 32-bit float is used to encode a texel."/>
					<value name="RGB_16F" doc="A three component buffer. A 16-bit float is used to encode a texel."/>
					<value name="RGB_32F" doc="A three component buffer. A 32-bit float is used to encode a texel."/>
					<value name="RGBA_16F" doc="A four component buffer. A 16-bit float is used to encode a texel."/>
					<value name="RGBA_32F" doc="A four component buffer. A 32-bit float is used to encode a texel."/>
					<value name="LUMINANCE_16F" doc="A single component buffer. A 16-bit float is used to encode a texel."/>
					<value name="LUMINANCE_32F" doc="A single component buffer. A 32-bit float is used to encode a texel."/>
					<value name="LUMINANCE_ALPHA_16F" doc="A two component buffer. A 16-bit float is used to encode a texel."/>
					<value name="LUMINANCE_ALPHA_32F" doc="A two component buffer. A 32-bit float is used to encode a texel."/>
				</enum>
			</type>
		</sf>

<!-- image format depth
 GL_TEXTURE_COMPARE_MODE
 GL_TEXTURE_COMPARE_FUNC
 usage SHADOWMAP -->

 		<includehpp>vgd/include/vgd/node/Texture.hpp</includehpp>
 		<includecpp>vgd/src/node/Texture.cpp</includecpp>
	</node>

	<node name = "Texture1D" inherits = "Texture" >
		<doxygen>
			<docBrief>Texture mapping node</docBrief>
			<doc>This property node defines a texture map and parameters for that map. This map is used to apply texture to subsequent shapes as they are rendered.</doc>
			<doc>@remarks Must be a 1d image (iimage.height() == iimage.depth() == 0).</doc>
			<ingroup>g_nodes</ingroup>
			<ingroup>g_multiAttributeNodes</ingroup>
			<ingroup>g_texturingNodes</ingroup>
		</doxygen>
		<includehpp>vgd/include/vgd/node/Texture1D.hpp</includehpp>
		<includecpp>vgd/src/node/Texture1D.cpp</includecpp>
	</node>

	<node name = "Texture2D" inherits = "Texture" >
		<doxygen>
			<docBrief>Texture mapping node</docBrief>
			<doc>This property node defines a texture map and parameters for that map. This map is used to apply texture to subsequent shapes as they are rendered.</doc>
			<ingroup>g_nodes</ingroup>
			<ingroup>g_multiAttributeNodes</ingroup>
			<ingroup>g_texturingNodes</ingroup>
		</doxygen>
		<includehpp>vgd/include/vgd/node/Texture2D.hpp</includehpp>
		<includecpp>vgd/src/node/Texture2D.cpp</includecpp>
	</node>



<!-- @todo abstract class -->



<!--	<node	name = "MaterialExt"
			inherits="Material">
		<doxygen>
			<docBrief>Extended surface material definition node</docBrief>
			<doc>The Material node specifies current surface material properties for all subsequent shapes nodes</doc>
			<doc> and is used by the lighting equations during rendering.</doc>
			<doc>The field \c transparency is not optional because it is used by others fields (in OpenGL ambient and others use 4 floats).</doc>
			<ingroup>g_nodes</ingroup>
			<ingroup>g_singleAttributeNodes</ingroup>
			<ingroup>g_coloringAndLightingNodes</ingroup>
		</doxygen>
	</node>-->

<!-- todo
	<node	name="SingleAttribute">
	</node> -->
</nodes>

<!-- test default value code generator
			<type name="float"></type>
			<type name="float" default="1.f"></type>
			<type name="Plane" namespace="vgm"></type>
			<type name="Plane" namespace="vgm" default=" "></type>
			<type name="Plane" namespace="vgm" default=" 0, 1, 2"></type>-->
