//// VGSDK - Copyright (C) 2012, 2014, Nicolas Papier.
//// Distributed under the terms of the GNU Library General Public License (LGPL)
//// as published by the Free Software Foundation.
//// Author Nicolas Papier
//
//#include "vgeGLBase/technique/Antialiasing.hpp"
//
//#include <vgd/basic/toString.hpp>
//#include <vgd/node/Group.hpp>
//#include <vgd/node/Antialiasing.hpp>
//#include <vgd/node/OutputBufferProperty.hpp>
//#include <vgd/node/PostProcessing.hpp>
//#include "vgeGLBase/engine/Engine.hpp"
//#include "vgeGLBase/handler/painter/OutputBuffers.hpp"
//#include "vgeGLBase/rc/Antialiasing.hpp"
//#include "vgeGLBase/technique/ForwardRendering.hpp"
//#include <vgm/operations.hpp>
//
//
//
//namespace vgeGLBase
//{
//
//namespace technique
//{
//
//
//
//void Antialiasing::stageCollectInformationsBegin( vgeGLBase::engine::Engine * engine )
//{
//	engine->regardIfIsA< vgd::node::Antialiasing >();
//}
//
//
//const bool Antialiasing::collectInformationsCallback( vge::visitor::TraverseElementVector::const_iterator iterator )
//{
//	if ( iterator->first->isA< vgd::node::Antialiasing >() && iterator->second )
//	{
//		setNode( iterator->first );
//		if ( getAntialiasingNode()->getTechnique() != vgd::node::Antialiasing::NONE )
//		{
//			setEnabled();
//		}
//		return true;
//	}
//	else
//	{
//		return false;
//	}
//}
//
//
//void Antialiasing::stageInitializeOutputBuffersNodes( vgd::Shp< vgeGLBase::rc::Antialiasing > rc )
//{
//	// OutputBufferProperty : COLOR RGBA
//	using vgd::node::OutputBufferProperty;
//	vgd::Shp< OutputBufferProperty > obufProperty;
//
//	obufProperty = OutputBufferProperty::create("vgsdk:colorRGBA", 0);
//	obufProperty->setFormat( OutputBufferProperty::RGBA );
//	obufProperty->setType( OutputBufferProperty::INTEGER );
//	obufProperty->setCommand( OutputBufferProperty::COLOR );
//	rc->colorBuffer = obufProperty;
//}
//
//
//void Antialiasing::stageInitializePostProcessing( vgd::node::Antialiasing * node, vgd::Shp< vgeGLBase::rc::Antialiasing > rc )
//{
//	// POST-PROCESSING
//	using vgd::node::Group;
//	using vgd::node::PostProcessing;
//	using vgeGLBase::engine::GLSLState;
//
//	vgd::Shp< Group > ppGroup = Group::create( "vgsdk:aa:postProcessing" );
//
//	vgd::Shp< PostProcessing > p;
//
//	p = PostProcessing::create("vgsdk:aa:apply");
//	p->setInput0( PostProcessing::OUTPUT_BUFFER0 );
//	p->setInput0Sampling( PostProcessing::LINEAR_MAXANISOTROPY4 );
//	p->setFilter( PostProcessing::CUSTOM_FILTER );
//
//	ppGroup->addChild( p );
//	rc->postProcessing.setState( 0, vgd::makeShp( new GLSLState::PostProcessingState(p.get()) ) );
//
//	rc->rootPostProcessing = ppGroup;
//}
//
//
//void Antialiasing::stageUpdatePostProcessingParameters( vgeGLBase::engine::Engine * engine, vgd::Shp< vgeGLBase::rc::Antialiasing > rc )
//{
//	if ( !isEnabled() )	return;
//
//	// Retrieves AA post-processing
//	using vgd::node::PostProcessing;
//	vgd::Shp< PostProcessing > aaPP = rc->rootPostProcessing->getChild< PostProcessing >( 0 );
//
//	// Sets the custom filter
//	const std::string customFilterDefinitionFXAAv1 =
//		"//#extension GL_EXT_gpu_shader4 : enable\n"
//		"\n"
//		"// Copyright for FXAA Source\n"
//		"//\n"
//		"// Copyright (c) 2010 NVIDIA Corporation. All rights reserved.\n"
//		"//\n"
//		"// TO  THE MAXIMUM  EXTENT PERMITTED  BY APPLICABLE  LAW, THIS SOFTWARE  IS PROVIDED\n"
//		"// *AS IS*  AND NVIDIA AND  ITS SUPPLIERS DISCLAIM  ALL WARRANTIES,  EITHER  EXPRESS\n"
//		"// OR IMPLIED, INCLUDING, BUT NOT LIMITED  TO, IMPLIED WARRANTIES OF MERCHANTABILITY\n"
//		"// AND FITNESS FOR A PARTICULAR PURPOSE.  IN NO EVENT SHALL  NVIDIA OR ITS SUPPLIERS\n"
//		"// BE  LIABLE  FOR  ANY  SPECIAL,  INCIDENTAL,  INDIRECT,  OR  CONSEQUENTIAL DAMAGES\n"
//		"// WHATSOEVER (INCLUDING, WITHOUT LIMITATION,  DAMAGES FOR LOSS OF BUSINESS PROFITS,\n"
//		"// BUSINESS INTERRUPTION, LOSS OF BUSINESS INFORMATION, OR ANY OTHER PECUNIARY LOSS)\n"
//		"// ARISING OUT OF THE  USE OF OR INABILITY  TO USE THIS SOFTWARE, EVEN IF NVIDIA HAS\n"
//		"// BEEN ADVISED OF THE POSSIBILITY OF SUCH DAMAGES.\n"
//		"\n"
//		//"#define FXAA_GLSL_120 1\n"
//		//"#define FXAA_GLSL_130 1\n"
//		"\n"
//		"/*============================================================================\n"
//		" \n"
//		"                                    FXAA                                 \n"
//		" \n"
//		"============================================================================*/\n"
//		" \n"
//		"/*============================================================================\n"
//		"                                 API PORTING\n"
//		"============================================================================*/\n"
//		"#ifndef     FXAA_GLSL_120\n"
//		"    #define FXAA_GLSL_120 0\n"
//		"#endif\n"
//		"#ifndef     FXAA_GLSL_130\n"
//		"    #define FXAA_GLSL_130 0\n"
//		"#endif\n"
//		// "#ifndef     FXAA_HLSL_3\n"
//		// "    #define FXAA_HLSL_3 0\n"
//		// "#endif\n"
//		// "#ifndef     FXAA_HLSL_4\n"
//		// "    #define FXAA_HLSL_4 0\n"
//		// "#endif    \n"
//		// "/*--------------------------------------------------------------------------*/\n"
//		// "#if FXAA_GLSL_120\n"
//		// "    // Requires,\n"
//		// "    //  #version 120\n"
//		// "    //  #extension GL_EXT_gpu_shader4 : enable\n"
//		// "    #define int2 ivec2\n"
//		// "    #define float2 vec2\n"
//		// "    #define float3 vec3\n"
//		// "    #define float4 vec4\n"
//		// "    #define FxaaBool3 bvec3\n"
//		// "    #define FxaaInt2 ivec2\n"
//		// "    #define FxaaFloat2 vec2\n"
//		// "    #define FxaaFloat3 vec3\n"
//		// "    #define FxaaFloat4 vec4\n"
//		// "    #define FxaaBool2Float(a) mix(0.0, 1.0, (a))\n"
//		// "    #define FxaaPow3(x, y) pow(x, y)\n"
//		// "    #define FxaaSel3(f, t, b) mix((f), (t), (b))\n"
//		// "    #define FxaaTex sampler2D\n"
//		// "    #define FxaaTexLod0(t, p) texture2DLod(t, p, 0.0)\n"
//		// "    #define FxaaTexOff(t, p, o, r) texture2DLodOffset(t, p, 0.0, o)\n"
//		// "#endif\n"
//		"/*--------------------------------------------------------------------------*/\n"
//		"#if FXAA_GLSL_130\n"
//		"    // Requires #version 130 or better\n"
//		"    #define int2 ivec2\n"
//		"    #define float2 vec2\n"
//		"    #define float3 vec3\n"
//		"    #define float4 vec4\n"
//		"    #define FxaaBool3 bvec3\n"
//		"    #define FxaaInt2 ivec2\n"
//		"    #define FxaaFloat2 vec2\n"
//		"    #define FxaaFloat3 vec3\n"
//		"    #define FxaaFloat4 vec4\n"
//		"    #define FxaaBool2Float(a) mix(0.0, 1.0, (a))\n"
//		"    #define FxaaPow3(x, y) pow(x, y)\n"
//		"    #define FxaaSel3(f, t, b) mix((f), (t), (b))\n"
//		"    #define FxaaTex sampler2D\n"
//		"    #define FxaaTexLod0(t, p) textureLod(t, p, 0.0)\n"
//		"    #define FxaaTexOff(t, p, o, r) textureLodOffset(t, p, 0.0, o)\n"
//		"#endif\n"
//		// "/*--------------------------------------------------------------------------*/\n"
//		// "#if FXAA_HLSL_3\n"
//		// "    #define int2 float2\n"
//		// "    #define FxaaInt2 float2\n"
//		// "    #define FxaaFloat2 float2\n"
//		// "    #define FxaaFloat3 float3\n"
//		// "    #define FxaaFloat4 float4\n"
//		// "    #define FxaaBool2Float(a) (a)\n"
//		// "    #define FxaaPow3(x, y) pow(x, y)\n"
//		// "    #define FxaaSel3(f, t, b) ((f)*(!b) + (t)*(b))\n"
//		// "    #define FxaaTex sampler2D\n"
//		// "    #define FxaaTexLod0(t, p) tex2Dlod(t, float4(p, 0.0, 0.0))\n"
//		// "    #define FxaaTexOff(t, p, o, r) tex2Dlod(t, float4(p + (o * r), 0, 0))\n"
//		// "#endif\n"
//		// "/*--------------------------------------------------------------------------*/\n"
//		// "#if FXAA_HLSL_4\n"
//		// "    #define FxaaInt2 int2\n"
//		// "    #define FxaaFloat2 float2\n"
//		// "    #define FxaaFloat3 float3\n"
//		// "    #define FxaaFloat4 float4\n"
//		// "    #define FxaaBool2Float(a) (a)\n"
//		// "    #define FxaaPow3(x, y) pow(x, y)\n"
//		// "    #define FxaaSel3(f, t, b) ((f)*(!b) + (t)*(b))\n"
//		// "    struct FxaaTex { SamplerState smpl; Texture2D tex; };\n"
//		// "    #define FxaaTexLod0(t, p) t.tex.SampleLevel(t.smpl, p, 0.0) \n"
//		// "    #define FxaaTexOff(t, p, o, r) t.tex.SampleLevel(t.smpl, p, 0.0, o)\n"
//		// "#endif\n"
//		"/*--------------------------------------------------------------------------*/\n"
//		"#define FxaaToFloat3(a) FxaaFloat3((a), (a), (a))\n"
//		"float4 FxaaTexGrad(FxaaTex tex, float2 pos, float2 grad) {\n"
//		"    #if FXAA_GLSL_120\n"
//		"        return texture2DGrad(tex, pos.xy, grad, grad);\n"
//		"    #endif\n"
//		"    #if FXAA_GLSL_130\n"
//		"        return textureGrad(tex, pos.xy, grad, grad);\n"
//		"    #endif\n"
//		// "    #if FXAA_HLSL_3\n"
//		// "        return tex2Dgrad(tex, pos.xy, grad, grad); \n"
//		// "    #endif\n"
//		// "    #if FXAA_HLSL_4\n"
//		// "        return tex.tex.SampleGrad(tex.smpl, pos.xy, grad, grad);\n"
//		// "    #endif\n"
//		"}\n"
//		"\n"
//		"/*============================================================================\n"
//		"                                 SRGB KNOBS\n"
//		"------------------------------------------------------------------------------\n"
//		"FXAA_SRGB_ROP - Set to 1 when applying FXAA to an sRGB back buffer (DX10/11).\n"
//		"                This will do the sRGB to linear transform, \n"
//		"                as ROP will expect linear color from this shader,\n"
//		"                and this shader works in non-linear color.\n"
//		"============================================================================*/\n"
//		"#define FXAA_SRGB_ROP 0\n"
//		"\n"
//		"/*============================================================================\n"
//		"                                DEBUG KNOBS\n"
//		"------------------------------------------------------------------------------\n"
//		"All debug knobs draw FXAA-untouched pixels in FXAA computed luma (monochrome).\n"
//		" \n"
//		"FXAA_DEBUG_PASSTHROUGH - Red for pixels which are filtered by FXAA with a\n"
//		"                         yellow tint on sub-pixel aliasing filtered by FXAA.\n"
//		"FXAA_DEBUG_HORZVERT    - Blue for horizontal edges, gold for vertical edges. \n"
//		"FXAA_DEBUG_PAIR        - Blue/green for the 2 pixel pair choice. \n"
//		"FXAA_DEBUG_NEGPOS      - Red/blue for which side of center of span.\n"
//		"FXAA_DEBUG_OFFSET      - Red/blue for -/+ x, gold/skyblue for -/+ y.\n"
//		"============================================================================*/\n"
//		"#ifndef     FXAA_DEBUG_PASSTHROUGH\n"
//		"    #define FXAA_DEBUG_PASSTHROUGH 0\n"
//		"#endif    \n"
//		"#ifndef     FXAA_DEBUG_HORZVERT\n"
//		"    #define FXAA_DEBUG_HORZVERT    0\n"
//		"#endif    \n"
//		"#ifndef     FXAA_DEBUG_PAIR   \n"
//		"    #define FXAA_DEBUG_PAIR        0\n"
//		"#endif    \n"
//		"#ifndef     FXAA_DEBUG_NEGPOS\n"
//		"    #define FXAA_DEBUG_NEGPOS      0\n"
//		"#endif\n"
//		"#ifndef     FXAA_DEBUG_OFFSET\n"
//		"    #define FXAA_DEBUG_OFFSET      0\n"
//		"#endif    \n"
//		"/*--------------------------------------------------------------------------*/\n"
//		"#if FXAA_DEBUG_PASSTHROUGH || FXAA_DEBUG_HORZVERT || FXAA_DEBUG_PAIR\n"
//		"    #define FXAA_DEBUG 1\n"
//		"#endif    \n"
//		"#if FXAA_DEBUG_NEGPOS || FXAA_DEBUG_OFFSET\n"
//		"    #define FXAA_DEBUG 1\n"
//		"#endif\n"
//		"#ifndef FXAA_DEBUG\n"
//		"    #define FXAA_DEBUG 0\n"
//		"#endif\n"
//		"  \n"
//		"/*============================================================================\n"
//		"                              COMPILE-IN KNOBS\n"
//		"------------------------------------------------------------------------------\n"
//		"FXAA_PRESET - Choose compile-in knob preset 0-5.\n"
//		"------------------------------------------------------------------------------\n"
//		"FXAA_EDGE_THRESHOLD - The minimum amount of local contrast required \n"
//		"                      to apply algorithm.\n"
//		"                      1.0/3.0  - too little\n"
//		"                      1.0/4.0  - good start\n"
//		"                      1.0/8.0  - applies to more edges\n"
//		"                      1.0/16.0 - overkill\n"
//		"------------------------------------------------------------------------------\n"
//		"FXAA_EDGE_THRESHOLD_MIN - Trims the algorithm from processing darks.\n"
//		"                          Perf optimization.\n"
//		"                          1.0/32.0 - visible limit (smaller isn't visible)\n"
//		"                          1.0/16.0 - good compromise\n"
//		"                          1.0/12.0 - upper limit (seeing artifacts)\n"
//		"------------------------------------------------------------------------------\n"
//		"FXAA_SEARCH_STEPS - Maximum number of search steps for end of span.\n"
//		"------------------------------------------------------------------------------\n"
//		"FXAA_SEARCH_ACCELERATION - How much to accelerate search,\n"
//		"                           1 - no acceleration\n"
//		"                           2 - skip by 2 pixels\n"
//		"                           3 - skip by 3 pixels\n"
//		"                           4 - skip by 4 pixels\n"
//		"------------------------------------------------------------------------------\n"
//		"FXAA_SEARCH_THRESHOLD - Controls when to stop searching.\n"
//		"                        1.0/4.0 - seems to be the best quality wise\n"
//		"------------------------------------------------------------------------------\n"
//		"FXAA_SUBPIX_FASTER - Turn on lower quality but faster subpix path.\n"
//		"                     Not recomended, but used in preset 0.\n"
//		"------------------------------------------------------------------------------\n"
//		"FXAA_SUBPIX - Toggle subpix filtering.\n"
//		"              0 - turn off\n"
//		"              1 - turn on\n"
//		"              2 - turn on full (ignores FXAA_SUBPIX_TRIM and CAP)\n"
//		"------------------------------------------------------------------------------\n"
//		"FXAA_SUBPIX_TRIM - Controls sub-pixel aliasing removal.\n"
//		"                   1.0/2.0 - low removal\n"
//		"                   1.0/3.0 - medium removal\n"
//		"                   1.0/4.0 - default removal\n"
//		"                   1.0/8.0 - high removal\n"
//		"                   0.0 - complete removal\n"
//		"------------------------------------------------------------------------------\n"
//		"FXAA_SUBPIX_CAP - Insures fine detail is not completely removed.\n"
//		"                  This is important for the transition of sub-pixel detail,\n"
//		"                  like fences and wires.\n"
//		"                  3.0/4.0 - default (medium amount of filtering)\n"
//		"                  7.0/8.0 - high amount of filtering\n"
//		"                  1.0 - no capping of sub-pixel aliasing removal\n"
//		"============================================================================*/\n"
//		"#ifndef FXAA_PRESET\n"
//		"    #define FXAA_PRESET 3\n"																			// @todo dynamic modif FXAA_PRESET
//		"#endif\n"
//		"/*--------------------------------------------------------------------------*/\n"
//		"#if (FXAA_PRESET == 0)\n"
//		"    #define FXAA_EDGE_THRESHOLD      (1.0/4.0)\n"
//		"    #define FXAA_EDGE_THRESHOLD_MIN  (1.0/12.0)\n"
//		"    #define FXAA_SEARCH_STEPS        2\n"
//		"    #define FXAA_SEARCH_ACCELERATION 4\n"
//		"    #define FXAA_SEARCH_THRESHOLD    (1.0/4.0)\n"
//		"    #define FXAA_SUBPIX              1\n"
//		"    #define FXAA_SUBPIX_FASTER       1\n"
//		"    #define FXAA_SUBPIX_CAP          (2.0/3.0)\n"
//		"    #define FXAA_SUBPIX_TRIM         (1.0/4.0)\n"
//		"#endif\n"
//		"/*--------------------------------------------------------------------------*/\n"
//		"#if (FXAA_PRESET == 1)\n"
//		"    #define FXAA_EDGE_THRESHOLD      (1.0/8.0)\n"
//		"    #define FXAA_EDGE_THRESHOLD_MIN  (1.0/16.0)\n"
//		"    #define FXAA_SEARCH_STEPS        4\n"
//		"    #define FXAA_SEARCH_ACCELERATION 3\n"
//		"    #define FXAA_SEARCH_THRESHOLD    (1.0/4.0)\n"
//		"    #define FXAA_SUBPIX              1\n"
//		"    #define FXAA_SUBPIX_FASTER       0\n"
//		"    #define FXAA_SUBPIX_CAP          (3.0/4.0)\n"
//		"    #define FXAA_SUBPIX_TRIM         (1.0/4.0)\n"
//		"#endif\n"
//		"/*--------------------------------------------------------------------------*/\n"
//		"#if (FXAA_PRESET == 2)\n"
//		"    #define FXAA_EDGE_THRESHOLD      (1.0/8.0)\n"
//		"    #define FXAA_EDGE_THRESHOLD_MIN  (1.0/24.0)\n"
//		"    #define FXAA_SEARCH_STEPS        8\n"
//		"    #define FXAA_SEARCH_ACCELERATION 2\n"
//		"    #define FXAA_SEARCH_THRESHOLD    (1.0/4.0)\n"
//		"    #define FXAA_SUBPIX              1\n"
//		"    #define FXAA_SUBPIX_FASTER       0\n"
//		"    #define FXAA_SUBPIX_CAP          (3.0/4.0)\n"
//		"    #define FXAA_SUBPIX_TRIM         (1.0/4.0)\n"
//		"#endif\n"
//		"/*--------------------------------------------------------------------------*/\n"
//		"#if (FXAA_PRESET == 3)\n"
//		"    #define FXAA_EDGE_THRESHOLD      (1.0/8.0)\n"
//		"    #define FXAA_EDGE_THRESHOLD_MIN  (1.0/24.0)\n"
//		"    #define FXAA_SEARCH_STEPS        16\n"
//		"    #define FXAA_SEARCH_ACCELERATION 1\n"
//		"    #define FXAA_SEARCH_THRESHOLD    (1.0/4.0)\n"
//		"    #define FXAA_SUBPIX              1\n"
//		"    #define FXAA_SUBPIX_FASTER       0\n"
//		"    #define FXAA_SUBPIX_CAP          (3.0/4.0)\n"
//		"    #define FXAA_SUBPIX_TRIM         (1.0/4.0)\n"
//		"#endif\n"
//		"/*--------------------------------------------------------------------------*/\n"
//		"#if (FXAA_PRESET == 4)\n"
//		"    #define FXAA_EDGE_THRESHOLD      (1.0/8.0)\n"
//		"    #define FXAA_EDGE_THRESHOLD_MIN  (1.0/24.0)\n"
//		"    #define FXAA_SEARCH_STEPS        24\n"
//		"    #define FXAA_SEARCH_ACCELERATION 1\n"
//		"    #define FXAA_SEARCH_THRESHOLD    (1.0/4.0)\n"
//		"    #define FXAA_SUBPIX              1\n"
//		"    #define FXAA_SUBPIX_FASTER       0\n"
//		"    #define FXAA_SUBPIX_CAP          (3.0/4.0)\n"
//		"    #define FXAA_SUBPIX_TRIM         (1.0/4.0)\n"
//		"#endif\n"
//		"/*--------------------------------------------------------------------------*/\n"
//		"#if (FXAA_PRESET == 5)\n"
//		"    #define FXAA_EDGE_THRESHOLD      (1.0/8.0)\n"
//		"    #define FXAA_EDGE_THRESHOLD_MIN  (1.0/24.0)\n"
//		"    #define FXAA_SEARCH_STEPS        32\n"
//		"    #define FXAA_SEARCH_ACCELERATION 1\n"
//		"    #define FXAA_SEARCH_THRESHOLD    (1.0/4.0)\n"
//		"    #define FXAA_SUBPIX              1\n"
//		"    #define FXAA_SUBPIX_FASTER       0\n"
//		"    #define FXAA_SUBPIX_CAP          (3.0/4.0)\n"
//		"    #define FXAA_SUBPIX_TRIM         (1.0/4.0)\n"
//		"#endif\n"
//		"/*--------------------------------------------------------------------------*/\n"
//		"#define FXAA_SUBPIX_TRIM_SCALE (1.0/(1.0 - FXAA_SUBPIX_TRIM))\n"
//		"\n"
//		"/*============================================================================\n"
//		"                                   HELPERS\n"
//		"============================================================================*/\n"
//		"// Return the luma, the estimation of luminance from rgb inputs.\n"
//		"// This approximates luma using one FMA instruction,\n"
//		"// skipping normalization and tossing out blue.\n"
//		"// FxaaLuma() will range 0.0 to 2.963210702.\n"
//		"float FxaaLuma(float3 rgb) {\n"
//		"    return rgb.y * (0.587/0.299) + rgb.x; } \n"
//		"/*--------------------------------------------------------------------------*/\n"
//		"float3 FxaaLerp3(float3 a, float3 b, float amountOfA) {\n"
//		"    return (FxaaToFloat3(-amountOfA) * b) + \n"
//		"        ((a * FxaaToFloat3(amountOfA)) + b); } \n"
//		"/*--------------------------------------------------------------------------*/\n"
//		"// Support any extra filtering before returning color.\n"
//		"float3 FxaaFilterReturn(float3 rgb) {\n"
//		"    #if FXAA_SRGB_ROP\n"
//		"        // Do sRGB encoded value to linear conversion.\n"
//		"        return FxaaSel3(\n"
//		"            rgb * FxaaToFloat3(1.0/12.92), \n"
//		"            FxaaPow3(\n"
//		"                rgb * FxaaToFloat3(1.0/1.055) + FxaaToFloat3(0.055/1.055), \n"
//		"                FxaaToFloat3(2.4)),\n"
//		"            rgb > FxaaToFloat3(0.04045)); \n"
//		"    #else\n"
//		"        return rgb;\n"
//		"    #endif\n"
//		"}\n"
//		" \n"
//		// "/*============================================================================\n"
//		// "                                VERTEX SHADER\n"
//		// "============================================================================*/\n"
//		// "float2 FxaaVertexShader(\n"
//		// "// Both x and y range {-1.0 to 1.0 across screen}.\n"
//		// "float2 inPos) {\n"
//		// "    float2 pos;\n"
//		// "    pos.xy = (inPos.xy * FxaaFloat2(0.5, 0.5)) + FxaaFloat2(0.5, 0.5);\n"
//		// "    return pos; }  \n"
//		// " \n"
//		// "/*============================================================================\n"
//		// " \n"
//		// "                                PIXEL SHADER\n"
//		// "                                \n"
//		// "============================================================================*/\n"
//		"float3 FxaaPixelShader(\n"
//		"// Output of FxaaVertexShader interpolated across screen.\n"
//		"//  xy -> actual texture position {0.0 to 1.0}\n"
//		"float2 pos,\n"
//		"// Input texture.\n"
//		"FxaaTex tex,\n"
//		"// RCPFRAME SHOULD PIXEL SHADER CONSTANTS!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!\n"
//		"// {1.0/frameWidth, 1.0/frameHeight}\n"												// @todo
//		"float2 rcpFrame) {\n"
//		"    \n"
//		"/*----------------------------------------------------------------------------\n"
//		"            EARLY EXIT IF LOCAL CONTRAST BELOW EDGE DETECT LIMIT\n"
//		"------------------------------------------------------------------------------\n"
//		"Majority of pixels of a typical image do not require filtering, \n"
//		"often pixels are grouped into blocks which could benefit from early exit \n"
//		"right at the beginning of the algorithm. \n"
//		"Given the following neighborhood, \n"
//		" \n"
//		"      N   \n"
//		"    W M E\n"
//		"      S   \n"
//		"    \n"
//		"If the difference in local maximum and minimum luma (contrast range) \n"
//		"is lower than a threshold proportional to the maximum local luma (rangeMax), \n"
//		"then the shader early exits (no visible aliasing). \n"
//		"This threshold is clamped at a minimum value (FXAA_EDGE_THRESHOLD_MIN)\n"
//		"to avoid processing in really dark areas.    \n"
//		"----------------------------------------------------------------------------*/\n"
//		"    float3 rgbN = FxaaTexOff(tex, pos.xy, FxaaInt2( 0,-1), rcpFrame).xyz;\n"
//		"    float3 rgbW = FxaaTexOff(tex, pos.xy, FxaaInt2(-1, 0), rcpFrame).xyz;\n"
//		"    float3 rgbM = FxaaTexOff(tex, pos.xy, FxaaInt2( 0, 0), rcpFrame).xyz;\n"
//		"    float3 rgbE = FxaaTexOff(tex, pos.xy, FxaaInt2( 1, 0), rcpFrame).xyz;\n"
//		"    float3 rgbS = FxaaTexOff(tex, pos.xy, FxaaInt2( 0, 1), rcpFrame).xyz;\n"
//		"    float lumaN = FxaaLuma(rgbN);\n"
//		"    float lumaW = FxaaLuma(rgbW);\n"
//		"    float lumaM = FxaaLuma(rgbM);\n"
//		"    float lumaE = FxaaLuma(rgbE);\n"
//		"    float lumaS = FxaaLuma(rgbS);\n"
//		"    float rangeMin = min(lumaM, min(min(lumaN, lumaW), min(lumaS, lumaE)));\n"
//		"    float rangeMax = max(lumaM, max(max(lumaN, lumaW), max(lumaS, lumaE)));\n"
//		"    float range = rangeMax - rangeMin;\n"
//		"    #if FXAA_DEBUG\n"
//		"        float lumaO = lumaM / (1.0 + (0.587/0.299));\n"
//		"    #endif        \n"
//		"    if(range < max(FXAA_EDGE_THRESHOLD_MIN, rangeMax * FXAA_EDGE_THRESHOLD)) {\n"
//		"        #if FXAA_DEBUG\n"
//		"            return FxaaFilterReturn(FxaaToFloat3(lumaO));\n"
//		"        #endif\n"
//		"        return FxaaFilterReturn(rgbM); }\n"
//		"    #if FXAA_SUBPIX > 0\n"
//		"        #if FXAA_SUBPIX_FASTER\n"
//		"            float3 rgbL = (rgbN + rgbW + rgbE + rgbS + rgbM) * \n"
//		"                FxaaToFloat3(1.0/5.0);\n"
//		"        #else\n"
//		"            float3 rgbL = rgbN + rgbW + rgbM + rgbE + rgbS;\n"
//		"        #endif\n"
//		"    #endif        \n"
//		"    \n"
//		"/*----------------------------------------------------------------------------\n"
//		"                               COMPUTE LOWPASS\n"
//		"------------------------------------------------------------------------------\n"
//		"FXAA computes a local neighborhood lowpass value as follows,\n"
//		" \n"
//		"  (N + W + E + S)/4\n"
//		"  \n"
//		"Then uses the ratio of the contrast range of the lowpass \n"
//		"and the range found in the early exit check, \n"
//		"as a sub-pixel aliasing detection filter. \n"
//		"When FXAA detects sub-pixel aliasing (such as single pixel dots), \n"
//		"it later blends in blendL amount \n"
//		"of a lowpass value (computed in the next section) to the final result.\n"
//		"----------------------------------------------------------------------------*/\n"
//		"    #if FXAA_SUBPIX != 0\n"
//		"        float lumaL = (lumaN + lumaW + lumaE + lumaS) * 0.25;\n"
//		"        float rangeL = abs(lumaL - lumaM);\n"
//		"    #endif        \n"
//		"    #if FXAA_SUBPIX == 1\n"
//		"        float blendL = max(0.0, \n"
//		"            (rangeL / range) - FXAA_SUBPIX_TRIM) * FXAA_SUBPIX_TRIM_SCALE; \n"
//		"        blendL = min(FXAA_SUBPIX_CAP, blendL);\n"
//		"    #endif\n"
//		"    #if FXAA_SUBPIX == 2\n"
//		"        float blendL = rangeL / range; \n"
//		"    #endif\n"
//		"    #if FXAA_DEBUG_PASSTHROUGH\n"
//		"        #if FXAA_SUBPIX == 0\n"
//		"            float blendL = 0.0;\n"
//		"        #endif\n"
//		"        return FxaaFilterReturn(\n"
//		"            FxaaFloat3(1.0, blendL/FXAA_SUBPIX_CAP, 0.0));\n"
//		"    #endif    \n"
//		"    \n"
//		"/*----------------------------------------------------------------------------\n"
//		"                    CHOOSE VERTICAL OR HORIZONTAL SEARCH\n"
//		"------------------------------------------------------------------------------\n"
//		"FXAA uses the following local neighborhood,\n"
//		" \n"
//		"    NW N NE\n"
//		"    W  M  E\n"
//		"    SW S SE\n"
//		"    \n"
//		"To compute an edge amount for both vertical and horizontal directions.\n"
//		"Note edge detect filters like Sobel fail on single pixel lines through M.\n"
//		"FXAA takes the weighted average magnitude of the high-pass values \n"
//		"for rows and columns as an indication of local edge amount.\n"
//		" \n"
//		"A lowpass value for anti-sub-pixel-aliasing is computed as \n"
//		"    (N+W+E+S+M+NW+NE+SW+SE)/9.\n"
//		"This full box pattern has higher quality than other options.\n"
//		" \n"
//		"Note following this block, both vertical and horizontal cases\n"
//		"flow in parallel (reusing the horizontal variables).\n"
//		"----------------------------------------------------------------------------*/\n"
//		"    float3 rgbNW = FxaaTexOff(tex, pos.xy, FxaaInt2(-1,-1), rcpFrame).xyz;\n"
//		"    float3 rgbNE = FxaaTexOff(tex, pos.xy, FxaaInt2( 1,-1), rcpFrame).xyz;\n"
//		"    float3 rgbSW = FxaaTexOff(tex, pos.xy, FxaaInt2(-1, 1), rcpFrame).xyz;\n"
//		"    float3 rgbSE = FxaaTexOff(tex, pos.xy, FxaaInt2( 1, 1), rcpFrame).xyz;\n"
//		"    #if (FXAA_SUBPIX_FASTER == 0) && (FXAA_SUBPIX > 0)\n"
//		"        rgbL += (rgbNW + rgbNE + rgbSW + rgbSE);\n"
//		"        rgbL *= FxaaToFloat3(1.0/9.0);\n"
//		"    #endif\n"
//		"    float lumaNW = FxaaLuma(rgbNW);\n"
//		"    float lumaNE = FxaaLuma(rgbNE);\n"
//		"    float lumaSW = FxaaLuma(rgbSW);\n"
//		"    float lumaSE = FxaaLuma(rgbSE);\n"
//		"    float edgeVert = \n"
//		"        abs((0.25 * lumaNW) + (-0.5 * lumaN) + (0.25 * lumaNE)) +\n"
//		"        abs((0.50 * lumaW ) + (-1.0 * lumaM) + (0.50 * lumaE )) +\n"
//		"        abs((0.25 * lumaSW) + (-0.5 * lumaS) + (0.25 * lumaSE));\n"
//		"    float edgeHorz = \n"
//		"        abs((0.25 * lumaNW) + (-0.5 * lumaW) + (0.25 * lumaSW)) +\n"
//		"        abs((0.50 * lumaN ) + (-1.0 * lumaM) + (0.50 * lumaS )) +\n"
//		"        abs((0.25 * lumaNE) + (-0.5 * lumaE) + (0.25 * lumaSE));\n"
//		"    bool horzSpan = edgeHorz >= edgeVert;\n"
//		"    #if FXAA_DEBUG_HORZVERT\n"
//		"        if(horzSpan) return FxaaFilterReturn(FxaaFloat3(1.0, 0.75, 0.0));\n"
//		"        else         return FxaaFilterReturn(FxaaFloat3(0.0, 0.50, 1.0));\n"
//		"    #endif\n"
//		"    float lengthSign = horzSpan ? -rcpFrame.y : -rcpFrame.x;\n"
//		"    if(!horzSpan) lumaN = lumaW;\n"
//		"    if(!horzSpan) lumaS = lumaE;\n"
//		"    float gradientN = abs(lumaN - lumaM);\n"
//		"    float gradientS = abs(lumaS - lumaM);\n"
//		"    lumaN = (lumaN + lumaM) * 0.5;\n"
//		"    lumaS = (lumaS + lumaM) * 0.5;\n"
//		"    \n"
//		"/*----------------------------------------------------------------------------\n"
//		"                CHOOSE SIDE OF PIXEL WHERE GRADIENT IS HIGHEST\n"
//		"------------------------------------------------------------------------------\n"
//		"This chooses a pixel pair. \n"
//		"For horzSpan == true this will be a vertical pair,\n"
//		" \n"
//		"    [N]     N\n"
//		"    [M] or [M]\n"
//		"     S     [S]\n"
//		" \n"
//		"Note following this block, both {N,M} and {S,M} cases\n"
//		"flow in parallel (reusing the {N,M} variables).\n"
//		" \n"
//		"This pair of image rows or columns is searched below\n"
//		"in the positive and negative direction \n"
//		"until edge status changes \n"
//		"(or the maximum number of search steps is reached).\n"
//		"----------------------------------------------------------------------------*/    \n"
//		"    bool pairN = gradientN >= gradientS;\n"
//		"    #if FXAA_DEBUG_PAIR\n"
//		"        if(pairN) return FxaaFilterReturn(FxaaFloat3(0.0, 0.0, 1.0));\n"
//		"        else      return FxaaFilterReturn(FxaaFloat3(0.0, 1.0, 0.0));\n"
//		"    #endif\n"
//		"    if(!pairN) lumaN = lumaS;\n"
//		"    if(!pairN) gradientN = gradientS;\n"
//		"    if(!pairN) lengthSign *= -1.0;\n"
//		"    float2 posN;\n"
//		"    posN.x = pos.x + (horzSpan ? 0.0 : lengthSign * 0.5);\n"
//		"    posN.y = pos.y + (horzSpan ? lengthSign * 0.5 : 0.0);\n"
//		"    \n"
//		"/*----------------------------------------------------------------------------\n"
//		"                         CHOOSE SEARCH LIMITING VALUES\n"
//		"------------------------------------------------------------------------------\n"
//		"Search limit (+/- gradientN) is a function of local gradient.\n"
//		"----------------------------------------------------------------------------*/\n"
//		"    gradientN *= FXAA_SEARCH_THRESHOLD;\n"
//		"    \n"
//		"/*----------------------------------------------------------------------------\n"
//		"    SEARCH IN BOTH DIRECTIONS UNTIL FIND LUMA PAIR AVERAGE IS OUT OF RANGE\n"
//		"------------------------------------------------------------------------------\n"
//		"This loop searches either in vertical or horizontal directions,\n"
//		"and in both the negative and positive direction in parallel.\n"
//		"This loop fusion is faster than searching separately.\n"
//		" \n"
//		"The search is accelerated using FXAA_SEARCH_ACCELERATION length box filter\n"
//		"via anisotropic filtering with specified texture gradients.\n"
//		"----------------------------------------------------------------------------*/\n"
//		"    float2 posP = posN;\n"
//		"    float2 offNP = horzSpan ? \n"
//		"        FxaaFloat2(rcpFrame.x, 0.0) :\n"
//		"        FxaaFloat2(0.0f, rcpFrame.y); \n"
//		"    float lumaEndN = lumaN;\n"
//		"    float lumaEndP = lumaN;\n"
//		"    bool doneN = false;\n"
//		"    bool doneP = false;\n"
//		"    #if FXAA_SEARCH_ACCELERATION == 1\n"
//		"        posN += offNP * FxaaFloat2(-1.0, -1.0);\n"
//		"        posP += offNP * FxaaFloat2( 1.0,  1.0);\n"
//		"    #endif\n"
//		"    #if FXAA_SEARCH_ACCELERATION == 2\n"
//		"        posN += offNP * FxaaFloat2(-1.5, -1.5);\n"
//		"        posP += offNP * FxaaFloat2( 1.5,  1.5);\n"
//		"        offNP *= FxaaFloat2(2.0, 2.0);\n"
//		"    #endif\n"
//		"    #if FXAA_SEARCH_ACCELERATION == 3\n"
//		"        posN += offNP * FxaaFloat2(-2.0, -2.0);\n"
//		"        posP += offNP * FxaaFloat2( 2.0,  2.0);\n"
//		"        offNP *= FxaaFloat2(3.0, 3.0);\n"
//		"    #endif\n"
//		"    #if FXAA_SEARCH_ACCELERATION == 4\n"
//		"        posN += offNP * FxaaFloat2(-2.5, -2.5);\n"
//		"        posP += offNP * FxaaFloat2( 2.5,  2.5);\n"
//		"        offNP *= FxaaFloat2(4.0, 4.0);\n"
//		"    #endif\n"
//		"    for(int i = 0; i < FXAA_SEARCH_STEPS; i++) {\n"
//		"        #if FXAA_SEARCH_ACCELERATION == 1\n"
//		"            if(!doneN) lumaEndN = \n"
//		"                FxaaLuma(FxaaTexLod0(tex, posN.xy).xyz);\n"
//		"            if(!doneP) lumaEndP = \n"
//		"                FxaaLuma(FxaaTexLod0(tex, posP.xy).xyz);\n"
//		"        #else\n"
//		"            if(!doneN) lumaEndN = \n"
//		"                FxaaLuma(FxaaTexGrad(tex, posN.xy, offNP).xyz);\n"
//		"            if(!doneP) lumaEndP = \n"
//		"                FxaaLuma(FxaaTexGrad(tex, posP.xy, offNP).xyz);\n"
//		"        #endif\n"
//		"        doneN = doneN || (abs(lumaEndN - lumaN) >= gradientN);\n"
//		"        doneP = doneP || (abs(lumaEndP - lumaN) >= gradientN);\n"
//		"        if(doneN && doneP) break;\n"
//		"        if(!doneN) posN -= offNP;\n"
//		"        if(!doneP) posP += offNP; }\n"
//		"    \n"
//		"/*----------------------------------------------------------------------------\n"
//		"               HANDLE IF CENTER IS ON POSITIVE OR NEGATIVE SIDE \n"
//		"------------------------------------------------------------------------------\n"
//		"FXAA uses the pixel's position in the span \n"
//		"in combination with the values (lumaEnd*) at the ends of the span,\n"
//		"to determine filtering.\n"
//		" \n"
//		"This step computes which side of the span the pixel is on. \n"
//		"On negative side if dstN < dstP,\n"
//		" \n"
//		"     posN        pos                      posP\n"
//		"      |-----------|------|------------------|\n"
//		"      |           |      |                  | \n"
//		"      |<--dstN--->|<---------dstP---------->|\n"
//		"                         |\n"
//		"                    span center\n"
//		"                    \n"
//		"----------------------------------------------------------------------------*/\n"
//		"    float dstN = horzSpan ? pos.x - posN.x : pos.y - posN.y;\n"
//		"    float dstP = horzSpan ? posP.x - pos.x : posP.y - pos.y;\n"
//		"    bool directionN = dstN < dstP;\n"
//		"    #if FXAA_DEBUG_NEGPOS\n"
//		"        if(directionN) return FxaaFilterReturn(FxaaFloat3(1.0, 0.0, 0.0));\n"
//		"        else           return FxaaFilterReturn(FxaaFloat3(0.0, 0.0, 1.0));\n"
//		"    #endif\n"
//		"    lumaEndN = directionN ? lumaEndN : lumaEndP;\n"
//		"    \n"
//		"/*----------------------------------------------------------------------------\n"
//		"         CHECK IF PIXEL IS IN SECTION OF SPAN WHICH GETS NO FILTERING\n"
//		"------------------------------------------------------------------------------\n"
//		"If both the pair luma at the end of the span (lumaEndN) \n"
//		"and middle pixel luma (lumaM)\n"
//		"are on the same side of the middle pair average luma (lumaN),\n"
//		"then don't filter.*/\n"
//		" \n"
//		// "Cases,\n"
//		// " \n"
//		// "(1.) L,\n"
//		// "  \n"
//		// "               lumaM\n"
//		// "                 |\n"
//		// "                 V    XXXXXXXX <- other line averaged\n"
//		// "         XXXXXXX[X]XXXXXXXXXXX <- source pixel line\n"
//		// "        |      .      | \n"
//		// "    --------------------------                    \n"
//		// "       [ ]xxxxxx[x]xx[X]XXXXXX <- pair average\n"
//		// "    --------------------------           \n"
//		// "        ^      ^ ^    ^\n"
//		// "        |      | |    |\n"
//		// "        .      |<---->|<---------- no filter region\n"
//		// "        .      | |    |\n"
//		// "        . center |    |\n"
//		// "        .        |  lumaEndN \n"
//		// "        .        |    .\n"
//		// "        .      lumaN  .\n"
//		// "        .             .\n"
//		// "        |<--- span -->|\n"
//		// "        \n"
//		// "                        \n"
//		// "(2.) ^ and -,\n"
//		// "  \n"
//		// "                               <- other line averaged\n"
//		// "          XXXXX[X]XXX          <- source pixel line\n"
//		// "         |     |     | \n"
//		// "    --------------------------                    \n"
//		// "        [ ]xxxx[x]xx[ ]        <- pair average\n"
//		// "    --------------------------           \n"
//		// "         |     |     |\n"
//		// "         |<--->|<--->|<---------- filter both sides\n"
//		// " \n"
//		// " \n"
//		// "(3.) v and inverse of -,\n"
//		// "  \n"
//		// "    XXXXXX           XXXXXXXXX <- other line averaged\n"
//		// "    XXXXXXXXXXX[X]XXXXXXXXXXXX <- source pixel line\n"
//		// "         |     |     |\n"
//		// "    --------------------------                    \n"
//		// "    XXXX[X]xxxx[x]xx[X]XXXXXXX <- pair average\n"
//		// "    --------------------------           \n"
//		// "         |     |     |\n"
//		// "         |<--->|<--->|<---------- don't filter both!\n"
//		// " \n"
//		// "         \n"
//		// "Note the v case for FXAA requires no filtering.\n"
//		// "This is because the inverse of the "-" case is the v.\n"
//		// "Filtering v case turns open spans like this,\n"
//		// " \n"
//		// "    XXXXXXXXX\n"
//		// "    \n"
//		// "Into this (which is not desired),\n"
//		// " \n"
//		// "    x+.   .+x\n"
//		// "    XXXXXXXXX\n"
//		// " \n"
//		//"----------------------------------------------------------------------------\n"
//
//		"    if(((lumaM - lumaN) < 0.0) == ((lumaEndN - lumaN) < 0.0)) \n"
//		"        lengthSign = 0.0;\n"
//		" \n"
//		"/*----------------------------------------------------------------------------\n"
//		"                COMPUTE SUB-PIXEL OFFSET AND FILTER SPAN\n"
//		"------------------------------------------------------------------------------\n"
//		"FXAA filters using a bilinear texture fetch offset \n"
//		"from the middle pixel M towards the center of the pair (NM below).\n"
//		"Maximum filtering will be half way between pair.\n"
//		"Reminder, at this point in the code, \n"
//		"the {N,M} pair is also reused for all cases: {S,M}, {W,M}, and {E,M}.\n*/"
//		" \n"
//		/*"    +-------+\n"
//		"    |       |    0.5 offset\n"
//		"    |   N   |     |\n"
//		"    |       |     V\n"
//		"    +-------+....---\n"
//		"    |       |\n"
//		"    |   M...|....---\n"
//		"    |       |     ^\n"
//		"    +-------+     |\n"
//		"    .       .    0.0 offset\n"
//		"    .   S   .\n"
//		"    .       .\n"
//		"    .........\n"
//		" \n"
//		"Position on span is used to compute sub-pixel filter offset using simple ramp,\n"
//		" \n"
//		"             posN           posP\n"
//		"              |\             |<------- 0.5 pixel offset into pair pixel\n"
//		"              | \            |\n"
//		"              |  \           |\n"
//		"    ---.......|...\..........|<------- 0.25 pixel offset into pair pixel\n"
//		"     ^        |   ^\         |\n"
//		"     |        |   | \        |\n"
//		"     V        |   |  \       |\n"
//		"    ---.......|===|==========|<------- 0.0 pixel offset (ie M pixel)\n"
//		"     ^        .   |   ^      .\n"
//		"     |        .  pos  |      .\n"
//		"     |        .   .   |      .\n"
//		"     |        .   . center   .\n"
//		"     |        .   .          .\n"
//		"     |        |<->|<---------.-------- dstN\n"
//		"     |        .   .          .    \n"
//		"     |        .   |<-------->|<------- dstP    \n"
//		"     |        .             .\n"
//		"     |        |<------------>|<------- spanLength    \n"
//		"     |\n"
//		"    subPixelOffset\n"
//		"    \n"
//		"----------------------------------------------------------------------------\n"*/
//		"    float spanLength = (dstP + dstN);\n"
//		"    dstN = directionN ? dstN : dstP;\n"
//		"    float subPixelOffset = (0.5 + (dstN * (-1.0/spanLength))) * lengthSign;\n"
//		"    #if FXAA_DEBUG_OFFSET\n"
//		"        float ox = horzSpan ? 0.0 : subPixelOffset*2.0/rcpFrame.x;\n"
//		"        float oy = horzSpan ? subPixelOffset*2.0/rcpFrame.y : 0.0;\n"
//		"        if(ox < 0.0) return FxaaFilterReturn(\n"
//		"            FxaaLerp3(FxaaToFloat3(lumaO), \n"
//		"                      FxaaFloat3(1.0, 0.0, 0.0), -ox));\n"
//		"        if(ox > 0.0) return FxaaFilterReturn(\n"
//		"            FxaaLerp3(FxaaToFloat3(lumaO), \n"
//		"                      FxaaFloat3(0.0, 0.0, 1.0),  ox));\n"
//		"        if(oy < 0.0) return FxaaFilterReturn(\n"
//		"            FxaaLerp3(FxaaToFloat3(lumaO), \n"
//		"                      FxaaFloat3(1.0, 0.6, 0.2), -oy));\n"
//		"        if(oy > 0.0) return FxaaFilterReturn(\n"
//		"            FxaaLerp3(FxaaToFloat3(lumaO), \n"
//		"                      FxaaFloat3(0.2, 0.6, 1.0),  oy));\n"
//		"        return FxaaFilterReturn(FxaaFloat3(lumaO, lumaO, lumaO));\n"
//		"    #endif\n"
//		"    float3 rgbF = FxaaTexLod0(tex, FxaaFloat2(\n"
//		"        pos.x + (horzSpan ? 0.0 : subPixelOffset),\n"
//		"        pos.y + (horzSpan ? subPixelOffset : 0.0))).xyz;\n"
//		"    #if FXAA_SUBPIX == 0\n"
//		"        return FxaaFilterReturn(rgbF); \n"
//		"    #else        \n"
//		"        return FxaaFilterReturn(FxaaLerp3(rgbL, rgbF, blendL)); \n"
//		"    #endif\n"
//		"}\n"
//		"\n"
//		"\n"
//		"\n"
//		"\n"
//		"vec4 apply( sampler2D tex, vec2 pos )"
//		"{\n"
//		"	float2 texSize = textureSize(tex, 0);\n"
//		"	float2 rcpFrame = float2(1.0/texSize.x, 1.0/texSize.y);\n"
//		"// passthrough\n"
//		"//return float4( texture(tex,pos) );\n"
//		"//	return float4( FxaaPixelShader( pos, tex, rcpFrame ), 1.0f );\n"
//		"	return float4( FxaaPixelShader( gl_FragCoord.xy*rcpFrame, tex, rcpFrame ), 1.0f );\n"
//		"}\n"
//		"\n\n\n";
//
//	const std::string customFilterDefinitionFXAAv3 =
//		"/*============================================================================\n"
//		//"\n"
//		//"\n"
//		"                    NVIDIA FXAA 3.11 by TIMOTHY LOTTES\n"
//		//"\n"
//		//"\n"
//		"------------------------------------------------------------------------------\n"
//		"COPYRIGHT (C) 2010, 2011 NVIDIA CORPORATION. ALL RIGHTS RESERVED.\n"
//		"------------------------------------------------------------------------------\n"
//		"TO THE MAXIMUM EXTENT PERMITTED BY APPLICABLE LAW, THIS SOFTWARE IS PROVIDED\n"
//		"*AS IS* AND NVIDIA AND ITS SUPPLIERS DISCLAIM ALL WARRANTIES, EITHER EXPRESS\n"
//		"OR IMPLIED, INCLUDING, BUT NOT LIMITED TO, IMPLIED WARRANTIES OF\n"
//		"MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE. IN NO EVENT SHALL NVIDIA\n"
//		"OR ITS SUPPLIERS BE LIABLE FOR ANY SPECIAL, INCIDENTAL, INDIRECT, OR\n"
//		"CONSEQUENTIAL DAMAGES WHATSOEVER (INCLUDING, WITHOUT LIMITATION, DAMAGES FOR\n"
//		"LOSS OF BUSINESS PROFITS, BUSINESS INTERRUPTION, LOSS OF BUSINESS INFORMATION,\n"
//		"OR ANY OTHER PECUNIARY LOSS) ARISING OUT OF THE USE OF OR INABILITY TO USE\n"
//		"THIS SOFTWARE, EVEN IF NVIDIA HAS BEEN ADVISED OF THE POSSIBILITY OF SUCH\n"
//		"DAMAGES.\n"
//		"\n"
//		//"------------------------------------------------------------------------------\n"
//		//"                           INTEGRATION CHECKLIST\n"
//		//"------------------------------------------------------------------------------\n"
//		//"(1.)\n"
//		//"In the shader source, setup defines for the desired configuration.\n"
//		//"When providing multiple shaders (for different presets),\n"
//		//"simply setup the defines differently in multiple files.\n"
//		//"Example,\n"
//		//"\n"
//		//"  #define FXAA_PC 1\n"
//		//"  #define FXAA_HLSL_5 1\n"
//		//"  #define FXAA_QUALITY__PRESET 12\n"
//		//"\n"
//		//"Or,\n"
//		//"\n"
//		//"  #define FXAA_360 1\n"
//		//"  \n"
//		//"Or,\n"
//		//"\n"
//		//"  #define FXAA_PS3 1\n"
//		//"  \n"
//		//"Etc.\n"
//		//"\n"
//		//"(2.)\n"
//		//"Then include this file,\n"
//		//"\n"
//		//"  #include \"Fxaa3_11.h\"\n"
//		//"\n"
//		//"(3.)\n"
//		//"Then call the FXAA pixel shader from within your desired shader.\n"
//		//"Look at the FXAA Quality FxaaPixelShader() for docs on inputs.\n"
//		//"As for FXAA 3.11 all inputs for all shaders are the same \n"
//		//"to enable easy porting between platforms.\n"
//		//"\n"
//		//"  return FxaaPixelShader(...);\n"
//		//"\n"
//		//"(4.)\n"
//		//"Insure pass prior to FXAA outputs RGBL (see next section).\n"
//		//"Or use,\n"
//		//"\n"
//		//"  #define FXAA_GREEN_AS_LUMA 1\n"
//		//"\n"
//		//"(5.)\n"
//		//"Setup engine to provide the following constants\n"
//		//"which are used in the FxaaPixelShader() inputs,\n"
//		//"\n"
//		//"  FxaaFloat2 fxaaQualityRcpFrame,\n"
//		//"  FxaaFloat4 fxaaConsoleRcpFrameOpt,\n"
//		//"  FxaaFloat4 fxaaConsoleRcpFrameOpt2,\n"
//		//"  FxaaFloat4 fxaaConsole360RcpFrameOpt2,\n"
//		//"  FxaaFloat fxaaQualitySubpix,\n"
//		//"  FxaaFloat fxaaQualityEdgeThreshold,\n"
//		//"  FxaaFloat fxaaQualityEdgeThresholdMin,\n"
//		//"  FxaaFloat fxaaConsoleEdgeSharpness,\n"
//		//"  FxaaFloat fxaaConsoleEdgeThreshold,\n"
//		//"  FxaaFloat fxaaConsoleEdgeThresholdMin,\n"
//		//"  FxaaFloat4 fxaaConsole360ConstDir\n"
//		//"\n"
//		//"Look at the FXAA Quality FxaaPixelShader() for docs on inputs.\n"
//		//"\n"
//		//"(6.)\n"
//		//"Have FXAA vertex shader run as a full screen triangle,\n"
//		//"and output \"pos\" and \"fxaaConsolePosPos\" \n"
//		//"such that inputs in the pixel shader provide,\n"
//		//"\n"
//		//"  // {xy} = center of pixel\n"
//		//"  FxaaFloat2 pos,\n"
//		//"\n"
//		//"  // {xy__} = upper left of pixel\n"
//		//"  // {__zw} = lower right of pixel\n"
//		//"  FxaaFloat4 fxaaConsolePosPos,\n"
//		//"\n"
//		//"(7.)\n"
//		//"Insure the texture sampler(s) used by FXAA are set to bilinear filtering.\n"
//		//"\n"
//		//"\n"
//		//"------------------------------------------------------------------------------\n"
//		//"                    INTEGRATION - RGBL AND COLORSPACE\n"
//		//"------------------------------------------------------------------------------\n"
//		//"FXAA3 requires RGBL as input unless the following is set, \n"
//		//"\n"
//		//"  #define FXAA_GREEN_AS_LUMA 1\n"
//		//"\n"
//		//"In which case the engine uses green in place of luma,\n"
//		//"and requires RGB input is in a non-linear colorspace.\n"
//		//"\n"
//		//"RGB should be LDR (low dynamic range).\n"
//		//"Specifically do FXAA after tonemapping.\n"
//		//"\n"
//		//"RGB data as returned by a texture fetch can be non-linear,\n"
//		//"or linear when FXAA_GREEN_AS_LUMA is not set.\n"
//		//"Note an \"sRGB format\" texture counts as linear,\n"
//		//"because the result of a texture fetch is linear data.\n"
//		//"Regular \"RGBA8\" textures in the sRGB colorspace are non-linear.\n"
//		//"\n"
//		//"If FXAA_GREEN_AS_LUMA is not set,\n"
//		//"luma must be stored in the alpha channel prior to running FXAA.\n"
//		//"This luma should be in a perceptual space (could be gamma 2.0).\n"
//		//"Example pass before FXAA where output is gamma 2.0 encoded,\n"
//		//"\n"
//		//"  color.rgb = ToneMap(color.rgb); // linear color output\n"
//		//"  color.rgb = sqrt(color.rgb);    // gamma 2.0 color output\n"
//		//"  return color;\n"
//		//"\n"
//		//"To use FXAA,\n"
//		//"\n"
//		//"  color.rgb = ToneMap(color.rgb);  // linear color output\n"
//		//"  color.rgb = sqrt(color.rgb);     // gamma 2.0 color output\n"
//		//"  color.a = dot(color.rgb, FxaaFloat3(0.299, 0.587, 0.114)); // compute luma\n"
//		//"  return color;\n"
//		//"\n"
//		//"Another example where output is linear encoded,\n"
//		//"say for instance writing to an sRGB formated render target,\n"
//		//"where the render target does the conversion back to sRGB after blending,\n"
//		//"\n"
//		//"  color.rgb = ToneMap(color.rgb); // linear color output\n"
//		//"  return color;\n"
//		//"\n"
//		//"To use FXAA,\n"
//		//"\n"
//		//"  color.rgb = ToneMap(color.rgb); // linear color output\n"
//		//"  color.a = sqrt(dot(color.rgb, FxaaFloat3(0.299, 0.587, 0.114))); // compute luma\n"
//		//"  return color;\n"
//		//"\n"
//		//"Getting luma correct is required for the algorithm to work correctly.\n"
//		//"\n"
//		//"\n"
//		//"------------------------------------------------------------------------------\n"
//		//"                          BEING LINEARLY CORRECT?\n"
//		//"------------------------------------------------------------------------------\n"
//		//"Applying FXAA to a framebuffer with linear RGB color will look worse.\n"
//		//"This is very counter intuitive, but happends to be true in this case.\n"
//		//"The reason is because dithering artifacts will be more visiable \n"
//		//"in a linear colorspace.\n"
//		//"\n"
//		//"\n"
//		//"------------------------------------------------------------------------------\n"
//		//"                             COMPLEX INTEGRATION\n"
//		//"------------------------------------------------------------------------------\n"
//		//"Q. What if the engine is blending into RGB before wanting to run FXAA?\n"
//		//"\n"
//		//"A. In the last opaque pass prior to FXAA,\n"
//		//"   have the pass write out luma into alpha.\n"
//		//"   Then blend into RGB only.\n"
//		//"   FXAA should be able to run ok\n"
//		//"   assuming the blending pass did not any add aliasing.\n"
//		//"   This should be the common case for particles and common blending passes.\n"
//		//"\n"
//		//"A. Or use FXAA_GREEN_AS_LUMA.\n"
//		//"\n"
//		//"============================================================================*/\n"
//		//"\n"
//		//"/*============================================================================\n"
//		//"\n"
//		//"                             INTEGRATION KNOBS\n"
//		//"\n"
//		//"============================================================================*/\n"
//		//"//\n"
//		//"// FXAA_PS3 and FXAA_360 choose the console algorithm (FXAA3 CONSOLE).\n"
//		//"// FXAA_360_OPT is a prototype for the new optimized 360 version.\n"
//		//"//\n"
//		//"// 1 = Use API.\n"
//		//"// 0 = Don't use API.\n"
//		//"//\n"
//		"/*--------------------------------------------------------------------------*/\n"
//		"#ifndef FXAA_PS3\n"
//		"    #define FXAA_PS3 0\n"
//		"#endif\n"
//		"/*--------------------------------------------------------------------------*/\n"
//		"#ifndef FXAA_360\n"
//		"    #define FXAA_360 0\n"
//		"#endif\n"
//		"/*--------------------------------------------------------------------------*/\n"
//		"#ifndef FXAA_360_OPT\n"
//		"    #define FXAA_360_OPT 0\n"
//		"#endif\n"
//		"/*==========================================================================*/\n"
//		"#ifndef FXAA_PC\n"
//		"    //\n"
//		"    // FXAA Quality\n"
//		"    // The high quality PC algorithm.\n"
//		"    //\n"
//		"    #define FXAA_PC 0\n"
//		"#endif\n"
//		"/*--------------------------------------------------------------------------*/\n"
//		"#ifndef FXAA_PC_CONSOLE\n"
//		"    //\n"
//		"    // The console algorithm for PC is included\n"
//		"    // for developers targeting really low spec machines.\n"
//		"    // Likely better to just run FXAA_PC, and use a really low preset.\n"
//		"    //\n"
//		"    #define FXAA_PC_CONSOLE 0\n"
//		"#endif\n"
//		"/*--------------------------------------------------------------------------*/\n"
//		"#ifndef FXAA_GLSL_120\n"
//		"    #define FXAA_GLSL_120 0\n"
//		"#endif\n"
//		"/*--------------------------------------------------------------------------*/\n"
//		"#ifndef FXAA_GLSL_130\n"
//		"    #define FXAA_GLSL_130 0\n"
//		"#endif\n"
//		//"/*--------------------------------------------------------------------------*/\n"
//		//"#ifndef FXAA_HLSL_3\n"
//		//"    #define FXAA_HLSL_3 0\n"
//		//"#endif\n"
//		//"/*--------------------------------------------------------------------------*/\n"
//		//"#ifndef FXAA_HLSL_4\n"
//		//"    #define FXAA_HLSL_4 0\n"
//		//"#endif\n"
//		//"/*--------------------------------------------------------------------------*/\n"
//		//"#ifndef FXAA_HLSL_5\n"
//		//"    #define FXAA_HLSL_5 0\n"
//		//"#endif\n"
//		"/*==========================================================================*/\n"
//		"#ifndef FXAA_GREEN_AS_LUMA\n"
//		//"    //\n"
//		//"    // For those using non-linear color,\n"
//		//"    // and either not able to get luma in alpha, or not wanting to,\n"
//		//"    // this enables FXAA to run using green as a proxy for luma.\n"
//		//"    // So with this enabled, no need to pack luma in alpha.\n"
//		//"    //\n"
//		//"    // This will turn off AA on anything which lacks some amount of green.\n"
//		//"    // Pure red and blue or combination of only R and B, will get no AA.\n"
//		//"    //\n"
//		//"    // Might want to lower the settings for both,\n"
//		//"    //    fxaaConsoleEdgeThresholdMin\n"
//		//"    //    fxaaQualityEdgeThresholdMin\n"
//		//"    // In order to insure AA does not get turned off on colors \n"
//		//"    // which contain a minor amount of green.\n"
//		//"    //\n"
//		//"    // 1 = On.\n"
//		//"    // 0 = Off.\n"
//		//"    //\n"
//		"    #define FXAA_GREEN_AS_LUMA 0\n"
//		"#endif\n"
//		"/*--------------------------------------------------------------------------*/\n"
//		"#ifndef FXAA_EARLY_EXIT\n"
//		//"    //\n"
//		//"    // Controls algorithm's early exit path.\n"
//		//"    // On PS3 turning this ON adds 2 cycles to the shader.\n"
//		//"    // On 360 turning this OFF adds 10ths of a millisecond to the shader.\n"
//		//"    // Turning this off on console will result in a more blurry image.\n"
//		//"    // So this defaults to on.\n"
//		//"    //\n"
//		//"    // 1 = On.\n"
//		//"    // 0 = Off.\n"
//		//"    //\n"
//		"    #define FXAA_EARLY_EXIT 1\n"
//		"#endif\n"
//		"/*--------------------------------------------------------------------------*/\n"
//		"#ifndef FXAA_DISCARD\n"
//		//"    //\n"
//		//"    // Only valid for PC OpenGL currently.\n"
//		//"    // Probably will not work when FXAA_GREEN_AS_LUMA = 1.\n"
//		//"    //\n"
//		//"    // 1 = Use discard on pixels which don't need AA.\n"
//		//"    //     For APIs which enable concurrent TEX+ROP from same surface.\n"
//		//"    // 0 = Return unchanged color on pixels which don't need AA.\n"
//		//"    //\n"
//		"    #define FXAA_DISCARD 0\n"
//		"#endif\n"
//		"/*--------------------------------------------------------------------------*/\n"
//		"#ifndef FXAA_FAST_PIXEL_OFFSET\n"
//		//"    //\n"
//		//"    // Used for GLSL 120 only.\n"
//		//"    //\n"
//		//"    // 1 = GL API supports fast pixel offsets\n"
//		//"    // 0 = do not use fast pixel offsets\n"
//		//"    //\n"
//		"    #ifdef GL_EXT_gpu_shader4\n"
//		"        #define FXAA_FAST_PIXEL_OFFSET 1\n"
//		"    #endif\n"
//		"    #ifdef GL_NV_gpu_shader5\n"
//		"        #define FXAA_FAST_PIXEL_OFFSET 1\n"
//		"    #endif\n"
//		"    #ifdef GL_ARB_gpu_shader5\n"
//		"        #define FXAA_FAST_PIXEL_OFFSET 1\n"
//		"    #endif\n"
//		"    #ifndef FXAA_FAST_PIXEL_OFFSET\n"
//		"        #define FXAA_FAST_PIXEL_OFFSET 0\n"
//		"    #endif\n"
//		"#endif\n"
//		"/*--------------------------------------------------------------------------*/\n"
//		"#ifndef FXAA_GATHER4_ALPHA\n"
//		//"    //\n"
//		//"    // 1 = API supports gather4 on alpha channel.\n"
//		//"    // 0 = API does not support gather4 on alpha channel.\n"
//		//"    //\n"
//		//"    #if (FXAA_HLSL_5 == 1)\n"
//		//"        #define FXAA_GATHER4_ALPHA 1\n"
//		//"    #endif\n"
//		"    #ifdef GL_ARB_gpu_shader5\n"
//		"        #define FXAA_GATHER4_ALPHA 1\n"
//		"    #endif\n"
//		"    #ifdef GL_NV_gpu_shader5\n"
//		"        #define FXAA_GATHER4_ALPHA 1\n"
//		"    #endif\n"
//		"    #ifndef FXAA_GATHER4_ALPHA\n"
//		"        #define FXAA_GATHER4_ALPHA 0\n"
//		"    #endif\n"
//		"#endif\n"
//		"\n"
//		"/*============================================================================\n"
//		"                      FXAA CONSOLE PS3 - TUNING KNOBS\n"
//		"============================================================================*/\n"
//		"#ifndef FXAA_CONSOLE__PS3_EDGE_SHARPNESS\n"
//		"    //\n"
//		"    // Consoles the sharpness of edges on PS3 only.\n"
//		"    // Non-PS3 tuning is done with shader input.\n"
//		"    //\n"
//		"    // Due to the PS3 being ALU bound,\n"
//		"    // there are only two safe values here: 4 and 8.\n"
//		"    // These options use the shaders ability to a free *|/ by 2|4|8.\n"
//		"    //\n"
//		"    // 8.0 is sharper\n"
//		"    // 4.0 is softer\n"
//		"    // 2.0 is really soft (good for vector graphics inputs)\n"
//		"    //\n"
//		"    #if 1\n"
//		"        #define FXAA_CONSOLE__PS3_EDGE_SHARPNESS 8.0\n"
//		"    #endif\n"
//		"    #if 0\n"
//		"        #define FXAA_CONSOLE__PS3_EDGE_SHARPNESS 4.0\n"
//		"    #endif\n"
//		"    #if 0\n"
//		"        #define FXAA_CONSOLE__PS3_EDGE_SHARPNESS 2.0\n"
//		"    #endif\n"
//		"#endif\n"
//		"/*--------------------------------------------------------------------------*/\n"
//		"#ifndef FXAA_CONSOLE__PS3_EDGE_THRESHOLD\n"
//		"    //\n"
//		"    // Only effects PS3.\n"
//		"    // Non-PS3 tuning is done with shader input.\n"
//		"    //\n"
//		"    // The minimum amount of local contrast required to apply algorithm.\n"
//		"    // The console setting has a different mapping than the quality setting.\n"
//		"    //\n"
//		"    // This only applies when FXAA_EARLY_EXIT is 1.\n"
//		"    //\n"
//		"    // Due to the PS3 being ALU bound,\n"
//		"    // there are only two safe values here: 0.25 and 0.125.\n"
//		"    // These options use the shaders ability to a free *|/ by 2|4|8.\n"
//		"    //\n"
//		"    // 0.125 leaves less aliasing, but is softer\n"
//		"    // 0.25 leaves more aliasing, and is sharper\n"
//		"    //\n"
//		"    #if 1\n"
//		"        #define FXAA_CONSOLE__PS3_EDGE_THRESHOLD 0.125\n"
//		"    #else\n"
//		"        #define FXAA_CONSOLE__PS3_EDGE_THRESHOLD 0.25\n"
//		"    #endif\n"
//		"#endif\n"
//		"\n"
//		"/*============================================================================\n"
//		"                        FXAA QUALITY - TUNING KNOBS\n"
//		"------------------------------------------------------------------------------\n"
//		"NOTE the other tuning knobs are now in the shader function inputs!\n"
//		"============================================================================*/\n"
//		"#ifndef FXAA_QUALITY__PRESET\n"
//		//"    //\n"
//		//"    // Choose the quality preset.\n"
//		//"    // This needs to be compiled into the shader as it effects code.\n"
//		//"    // Best option to include multiple presets is to \n"
//		//"    // in each shader define the preset, then include this file.\n"
//		//"    // \n"
//		//"    // OPTIONS\n"
//		//"    // -----------------------------------------------------------------------\n"
//		//"    // 10 to 15 - default medium dither (10=fastest, 15=highest quality)\n"
//		//"    // 20 to 29 - less dither, more expensive (20=fastest, 29=highest quality)\n"
//		//"    // 39       - no dither, very expensive \n"
//		//"    //\n"
//		//"    // NOTES\n"
//		//"    // -----------------------------------------------------------------------\n"
//		//"    // 12 = slightly faster then FXAA 3.9 and higher edge quality (default)\n"
//		//"    // 13 = about same speed as FXAA 3.9 and better than 12\n"
//		//"    // 23 = closest to FXAA 3.9 visually and performance wise\n"
//		//"    //  _ = the lowest digit is directly related to performance\n"
//		//"    // _  = the highest digit is directly related to style\n"
//		//"    // \n"
//		"    #define FXAA_QUALITY__PRESET 12\n"
//		"#endif\n"
//		"\n"
//		"\n"
//		"/*============================================================================\n"
//		"\n"
//		"                           FXAA QUALITY - PRESETS\n"
//		"\n"
//		"============================================================================*/\n"
//		"\n"
//		"/*============================================================================\n"
//		"                     FXAA QUALITY - MEDIUM DITHER PRESETS\n"
//		"============================================================================*/\n"
//		"#if (FXAA_QUALITY__PRESET == 10)\n"
//		"    #define FXAA_QUALITY__PS 3\n"
//		"    #define FXAA_QUALITY__P0 1.5\n"
//		"    #define FXAA_QUALITY__P1 3.0\n"
//		"    #define FXAA_QUALITY__P2 12.0\n"
//		"#endif\n"
//		"/*--------------------------------------------------------------------------*/\n"
//		"#if (FXAA_QUALITY__PRESET == 11)\n"
//		"    #define FXAA_QUALITY__PS 4\n"
//		"    #define FXAA_QUALITY__P0 1.0\n"
//		"    #define FXAA_QUALITY__P1 1.5\n"
//		"    #define FXAA_QUALITY__P2 3.0\n"
//		"    #define FXAA_QUALITY__P3 12.0\n"
//		"#endif\n"
//		"/*--------------------------------------------------------------------------*/\n"
//		"#if (FXAA_QUALITY__PRESET == 12)\n"
//		"    #define FXAA_QUALITY__PS 5\n"
//		"    #define FXAA_QUALITY__P0 1.0\n"
//		"    #define FXAA_QUALITY__P1 1.5\n"
//		"    #define FXAA_QUALITY__P2 2.0\n"
//		"    #define FXAA_QUALITY__P3 4.0\n"
//		"    #define FXAA_QUALITY__P4 12.0\n"
//		"#endif\n"
//		"/*--------------------------------------------------------------------------*/\n"
//		"#if (FXAA_QUALITY__PRESET == 13)\n"
//		"    #define FXAA_QUALITY__PS 6\n"
//		"    #define FXAA_QUALITY__P0 1.0\n"
//		"    #define FXAA_QUALITY__P1 1.5\n"
//		"    #define FXAA_QUALITY__P2 2.0\n"
//		"    #define FXAA_QUALITY__P3 2.0\n"
//		"    #define FXAA_QUALITY__P4 4.0\n"
//		"    #define FXAA_QUALITY__P5 12.0\n"
//		"#endif\n"
//		"/*--------------------------------------------------------------------------*/\n"
//		"#if (FXAA_QUALITY__PRESET == 14)\n"
//		"    #define FXAA_QUALITY__PS 7\n"
//		"    #define FXAA_QUALITY__P0 1.0\n"
//		"    #define FXAA_QUALITY__P1 1.5\n"
//		"    #define FXAA_QUALITY__P2 2.0\n"
//		"    #define FXAA_QUALITY__P3 2.0\n"
//		"    #define FXAA_QUALITY__P4 2.0\n"
//		"    #define FXAA_QUALITY__P5 4.0\n"
//		"    #define FXAA_QUALITY__P6 12.0\n"
//		"#endif\n"
//		"/*--------------------------------------------------------------------------*/\n"
//		"#if (FXAA_QUALITY__PRESET == 15)\n"
//		"    #define FXAA_QUALITY__PS 8\n"
//		"    #define FXAA_QUALITY__P0 1.0\n"
//		"    #define FXAA_QUALITY__P1 1.5\n"
//		"    #define FXAA_QUALITY__P2 2.0\n"
//		"    #define FXAA_QUALITY__P3 2.0\n"
//		"    #define FXAA_QUALITY__P4 2.0\n"
//		"    #define FXAA_QUALITY__P5 2.0\n"
//		"    #define FXAA_QUALITY__P6 4.0\n"
//		"    #define FXAA_QUALITY__P7 12.0\n"
//		"#endif\n"
//		"\n"
//		"/*============================================================================\n"
//		"                     FXAA QUALITY - LOW DITHER PRESETS\n"
//		"============================================================================*/\n"
//		"#if (FXAA_QUALITY__PRESET == 20)\n"
//		"    #define FXAA_QUALITY__PS 3\n"
//		"    #define FXAA_QUALITY__P0 1.5\n"
//		"    #define FXAA_QUALITY__P1 2.0\n"
//		"    #define FXAA_QUALITY__P2 8.0\n"
//		"#endif\n"
//		"/*--------------------------------------------------------------------------*/\n"
//		"#if (FXAA_QUALITY__PRESET == 21)\n"
//		"    #define FXAA_QUALITY__PS 4\n"
//		"    #define FXAA_QUALITY__P0 1.0\n"
//		"    #define FXAA_QUALITY__P1 1.5\n"
//		"    #define FXAA_QUALITY__P2 2.0\n"
//		"    #define FXAA_QUALITY__P3 8.0\n"
//		"#endif\n"
//		"/*--------------------------------------------------------------------------*/\n"
//		"#if (FXAA_QUALITY__PRESET == 22)\n"
//		"    #define FXAA_QUALITY__PS 5\n"
//		"    #define FXAA_QUALITY__P0 1.0\n"
//		"    #define FXAA_QUALITY__P1 1.5\n"
//		"    #define FXAA_QUALITY__P2 2.0\n"
//		"    #define FXAA_QUALITY__P3 2.0\n"
//		"    #define FXAA_QUALITY__P4 8.0\n"
//		"#endif\n"
//		"/*--------------------------------------------------------------------------*/\n"
//		"#if (FXAA_QUALITY__PRESET == 23)\n"
//		"    #define FXAA_QUALITY__PS 6\n"
//		"    #define FXAA_QUALITY__P0 1.0\n"
//		"    #define FXAA_QUALITY__P1 1.5\n"
//		"    #define FXAA_QUALITY__P2 2.0\n"
//		"    #define FXAA_QUALITY__P3 2.0\n"
//		"    #define FXAA_QUALITY__P4 2.0\n"
//		"    #define FXAA_QUALITY__P5 8.0\n"
//		"#endif\n"
//		"/*--------------------------------------------------------------------------*/\n"
//		"#if (FXAA_QUALITY__PRESET == 24)\n"
//		"    #define FXAA_QUALITY__PS 7\n"
//		"    #define FXAA_QUALITY__P0 1.0\n"
//		"    #define FXAA_QUALITY__P1 1.5\n"
//		"    #define FXAA_QUALITY__P2 2.0\n"
//		"    #define FXAA_QUALITY__P3 2.0\n"
//		"    #define FXAA_QUALITY__P4 2.0\n"
//		"    #define FXAA_QUALITY__P5 3.0\n"
//		"    #define FXAA_QUALITY__P6 8.0\n"
//		"#endif\n"
//		"/*--------------------------------------------------------------------------*/\n"
//		"#if (FXAA_QUALITY__PRESET == 25)\n"
//		"    #define FXAA_QUALITY__PS 8\n"
//		"    #define FXAA_QUALITY__P0 1.0\n"
//		"    #define FXAA_QUALITY__P1 1.5\n"
//		"    #define FXAA_QUALITY__P2 2.0\n"
//		"    #define FXAA_QUALITY__P3 2.0\n"
//		"    #define FXAA_QUALITY__P4 2.0\n"
//		"    #define FXAA_QUALITY__P5 2.0\n"
//		"    #define FXAA_QUALITY__P6 4.0\n"
//		"    #define FXAA_QUALITY__P7 8.0\n"
//		"#endif\n"
//		"/*--------------------------------------------------------------------------*/\n"
//		"#if (FXAA_QUALITY__PRESET == 26)\n"
//		"    #define FXAA_QUALITY__PS 9\n"
//		"    #define FXAA_QUALITY__P0 1.0\n"
//		"    #define FXAA_QUALITY__P1 1.5\n"
//		"    #define FXAA_QUALITY__P2 2.0\n"
//		"    #define FXAA_QUALITY__P3 2.0\n"
//		"    #define FXAA_QUALITY__P4 2.0\n"
//		"    #define FXAA_QUALITY__P5 2.0\n"
//		"    #define FXAA_QUALITY__P6 2.0\n"
//		"    #define FXAA_QUALITY__P7 4.0\n"
//		"    #define FXAA_QUALITY__P8 8.0\n"
//		"#endif\n"
//		"/*--------------------------------------------------------------------------*/\n"
//		"#if (FXAA_QUALITY__PRESET == 27)\n"
//		"    #define FXAA_QUALITY__PS 10\n"
//		"    #define FXAA_QUALITY__P0 1.0\n"
//		"    #define FXAA_QUALITY__P1 1.5\n"
//		"    #define FXAA_QUALITY__P2 2.0\n"
//		"    #define FXAA_QUALITY__P3 2.0\n"
//		"    #define FXAA_QUALITY__P4 2.0\n"
//		"    #define FXAA_QUALITY__P5 2.0\n"
//		"    #define FXAA_QUALITY__P6 2.0\n"
//		"    #define FXAA_QUALITY__P7 2.0\n"
//		"    #define FXAA_QUALITY__P8 4.0\n"
//		"    #define FXAA_QUALITY__P9 8.0\n"
//		"#endif\n"
//		"/*--------------------------------------------------------------------------*/\n"
//		"#if (FXAA_QUALITY__PRESET == 28)\n"
//		"    #define FXAA_QUALITY__PS 11\n"
//		"    #define FXAA_QUALITY__P0 1.0\n"
//		"    #define FXAA_QUALITY__P1 1.5\n"
//		"    #define FXAA_QUALITY__P2 2.0\n"
//		"    #define FXAA_QUALITY__P3 2.0\n"
//		"    #define FXAA_QUALITY__P4 2.0\n"
//		"    #define FXAA_QUALITY__P5 2.0\n"
//		"    #define FXAA_QUALITY__P6 2.0\n"
//		"    #define FXAA_QUALITY__P7 2.0\n"
//		"    #define FXAA_QUALITY__P8 2.0\n"
//		"    #define FXAA_QUALITY__P9 4.0\n"
//		"    #define FXAA_QUALITY__P10 8.0\n"
//		"#endif\n"
//		"/*--------------------------------------------------------------------------*/\n"
//		"#if (FXAA_QUALITY__PRESET == 29)\n"
//		"    #define FXAA_QUALITY__PS 12\n"
//		"    #define FXAA_QUALITY__P0 1.0\n"
//		"    #define FXAA_QUALITY__P1 1.5\n"
//		"    #define FXAA_QUALITY__P2 2.0\n"
//		"    #define FXAA_QUALITY__P3 2.0\n"
//		"    #define FXAA_QUALITY__P4 2.0\n"
//		"    #define FXAA_QUALITY__P5 2.0\n"
//		"    #define FXAA_QUALITY__P6 2.0\n"
//		"    #define FXAA_QUALITY__P7 2.0\n"
//		"    #define FXAA_QUALITY__P8 2.0\n"
//		"    #define FXAA_QUALITY__P9 2.0\n"
//		"    #define FXAA_QUALITY__P10 4.0\n"
//		"    #define FXAA_QUALITY__P11 8.0\n"
//		"#endif\n"
//		"\n"
//		"/*============================================================================\n"
//		"                     FXAA QUALITY - EXTREME QUALITY\n"
//		"============================================================================*/\n"
//		"#if (FXAA_QUALITY__PRESET == 39)\n"
//		"    #define FXAA_QUALITY__PS 12\n"
//		"    #define FXAA_QUALITY__P0 1.0\n"
//		"    #define FXAA_QUALITY__P1 1.0\n"
//		"    #define FXAA_QUALITY__P2 1.0\n"
//		"    #define FXAA_QUALITY__P3 1.0\n"
//		"    #define FXAA_QUALITY__P4 1.0\n"
//		"    #define FXAA_QUALITY__P5 1.5\n"
//		"    #define FXAA_QUALITY__P6 2.0\n"
//		"    #define FXAA_QUALITY__P7 2.0\n"
//		"    #define FXAA_QUALITY__P8 2.0\n"
//		"    #define FXAA_QUALITY__P9 2.0\n"
//		"    #define FXAA_QUALITY__P10 4.0\n"
//		"    #define FXAA_QUALITY__P11 8.0\n"
//		"#endif\n"
//		"\n"
//		"\n"
//		"\n"
//		"/*============================================================================\n"
//		"\n"
//		"                                API PORTING\n"
//		"\n"
//		"============================================================================*/\n"
//		"#if (FXAA_GLSL_120 == 1) || (FXAA_GLSL_130 == 1)\n"
//		"    #define FxaaBool bool\n"
//		"    #define FxaaDiscard discard\n"
//		"    #define FxaaFloat float\n"
//		"    #define FxaaFloat2 vec2\n"
//		"    #define FxaaFloat3 vec3\n"
//		"    #define FxaaFloat4 vec4\n"
//		"    #define FxaaHalf float\n"
//		"    #define FxaaHalf2 vec2\n"
//		"    #define FxaaHalf3 vec3\n"
//		"    #define FxaaHalf4 vec4\n"
//		"    #define FxaaInt2 ivec2\n"
//		"    #define FxaaSat(x) clamp(x, 0.0, 1.0)\n"
//		"    #define FxaaTex sampler2D\n"
//		"#else\n"
//		"    #define FxaaBool bool\n"
//		"    #define FxaaDiscard clip(-1)\n"
//		"    #define FxaaFloat float\n"
//		"    #define FxaaFloat2 float2\n"
//		"    #define FxaaFloat3 float3\n"
//		"    #define FxaaFloat4 float4\n"
//		"    #define FxaaHalf half\n"
//		"    #define FxaaHalf2 half2\n"
//		"    #define FxaaHalf3 half3\n"
//		"    #define FxaaHalf4 half4\n"
//		"    #define FxaaSat(x) saturate(x)\n"
//		"#endif\n"
//		//"/*--------------------------------------------------------------------------*/\n"
//		//"#if (FXAA_GLSL_120 == 1)\n"
//		//"    // Requires,\n"
//		//"    //  #version 120\n"
//		//"    // And at least,\n"
//		//"    //  #extension GL_EXT_gpu_shader4 : enable\n"
//		//"    //  (or set FXAA_FAST_PIXEL_OFFSET 1 to work like DX9)\n"
//		//"    #define FxaaTexTop(t, p) texture2DLod(t, p, 0.0)\n"
//		//"    #if (FXAA_FAST_PIXEL_OFFSET == 1)\n"
//		//"        #define FxaaTexOff(t, p, o, r) texture2DLodOffset(t, p, 0.0, o)\n"
//		//"    #else\n"
//		//"        #define FxaaTexOff(t, p, o, r) texture2DLod(t, p + (o * r), 0.0)\n"
//		//"    #endif\n"
//		//"    #if (FXAA_GATHER4_ALPHA == 1)\n"
//		//"        // use #extension GL_ARB_gpu_shader5 : enable\n"
//		//"        #define FxaaTexAlpha4(t, p) textureGather(t, p, 3)\n"
//		//"        #define FxaaTexOffAlpha4(t, p, o) textureGatherOffset(t, p, o, 3)\n"
//		//"        #define FxaaTexGreen4(t, p) textureGather(t, p, 1)\n"
//		//"        #define FxaaTexOffGreen4(t, p, o) textureGatherOffset(t, p, o, 1)\n"
//		//"    #endif\n"
//		//"#endif\n"
//		"/*--------------------------------------------------------------------------*/\n"
//		"#if (FXAA_GLSL_130 == 1)\n"
//		"    // Requires \"#version 130\" or better\n"
//		"    #define FxaaTexTop(t, p) textureLod(t, p, 0.0)\n"
//		"    #define FxaaTexOff(t, p, o, r) textureLodOffset(t, p, 0.0, o)\n"
//		"    #if (FXAA_GATHER4_ALPHA == 1)\n"
//		"        // use #extension GL_ARB_gpu_shader5 : enable\n"
//		"        #define FxaaTexAlpha4(t, p) textureGather(t, p, 3)\n"
//		"        #define FxaaTexOffAlpha4(t, p, o) textureGatherOffset(t, p, o, 3)\n"
//		"        #define FxaaTexGreen4(t, p) textureGather(t, p, 1)\n"
//		"        #define FxaaTexOffGreen4(t, p, o) textureGatherOffset(t, p, o, 1)\n"
//		"    #endif\n"
//		"#endif\n"
//		//"/*--------------------------------------------------------------------------*/\n"
//		//"#if (FXAA_HLSL_3 == 1) || (FXAA_360 == 1) || (FXAA_PS3 == 1)\n"
//		//"    #define FxaaInt2 float2\n"
//		//"    #define FxaaTex sampler2D\n"
//		//"    #define FxaaTexTop(t, p) tex2Dlod(t, float4(p, 0.0, 0.0))\n"
//		//"    #define FxaaTexOff(t, p, o, r) tex2Dlod(t, float4(p + (o * r), 0, 0))\n"
//		//"#endif\n"
//		//"/*--------------------------------------------------------------------------*/\n"
//		//"#if (FXAA_HLSL_4 == 1)\n"
//		//"    #define FxaaInt2 int2\n"
//		//"    struct FxaaTex { SamplerState smpl; Texture2D tex; };\n"
//		//"    #define FxaaTexTop(t, p) t.tex.SampleLevel(t.smpl, p, 0.0)\n"
//		//"    #define FxaaTexOff(t, p, o, r) t.tex.SampleLevel(t.smpl, p, 0.0, o)\n"
//		//"#endif\n"
//		//"/*--------------------------------------------------------------------------*/\n"
//		//"#if (FXAA_HLSL_5 == 1)\n"
//		//"    #define FxaaInt2 int2\n"
//		//"    struct FxaaTex { SamplerState smpl; Texture2D tex; };\n"
//		//"    #define FxaaTexTop(t, p) t.tex.SampleLevel(t.smpl, p, 0.0)\n"
//		//"    #define FxaaTexOff(t, p, o, r) t.tex.SampleLevel(t.smpl, p, 0.0, o)\n"
//		//"    #define FxaaTexAlpha4(t, p) t.tex.GatherAlpha(t.smpl, p)\n"
//		//"    #define FxaaTexOffAlpha4(t, p, o) t.tex.GatherAlpha(t.smpl, p, o)\n"
//		//"    #define FxaaTexGreen4(t, p) t.tex.GatherGreen(t.smpl, p)\n"
//		//"    #define FxaaTexOffGreen4(t, p, o) t.tex.GatherGreen(t.smpl, p, o)\n"
//		//"#endif\n"
//		//"\n"
//		//"\n"
//		"/*============================================================================\n"
//		"                   GREEN AS LUMA OPTION SUPPORT FUNCTION\n"
//		"============================================================================*/\n"
//		"#if (FXAA_GREEN_AS_LUMA == 0)\n"
//		"    FxaaFloat FxaaLuma(FxaaFloat4 rgba) { return rgba.w; }\n"
//		"#else\n"
//		"    FxaaFloat FxaaLuma(FxaaFloat4 rgba) { return rgba.y; }\n"
//		"#endif    \n"
//		"\n"
//		//"\n"
//		//"\n"
//		//"\n"
//		"/*============================================================================\n"
//		//"\n"
//		"                             FXAA3 QUALITY - PC\n"
//		//"\n"
//		"============================================================================*/\n"
//		"#if (FXAA_PC == 1)\n"
//		"/*--------------------------------------------------------------------------*/\n"
//		"FxaaFloat4 FxaaPixelShader(\n"
//		//"    //\n"
//		//"    // Use noperspective interpolation here (turn off perspective interpolation).\n"
//		//"    // {xy} = center of pixel\n"
//		"    FxaaFloat2 pos,\n"
//		//"    //\n"
//		//"    // Used only for FXAA Console, and not used on the 360 version.\n"
//		//"    // Use noperspective interpolation here (turn off perspective interpolation).\n"
//		//"    // {xy__} = upper left of pixel\n"
//		//"    // {__zw} = lower right of pixel\n"
//		"    FxaaFloat4 fxaaConsolePosPos,\n"
//		//"    //\n"
//		//"    // Input color texture.\n"
//		//"    // {rgb_} = color in linear or perceptual color space\n"
//		//"    // if (FXAA_GREEN_AS_LUMA == 0)\n"
//		//"    //     {___a} = luma in perceptual color space (not linear)\n"
//		"    FxaaTex tex,\n"
//		//"    //\n"
//		//"    // Only used on the optimized 360 version of FXAA Console.\n"
//		//"    // For everything but 360, just use the same input here as for \"tex\".\n"
//		//"    // For 360, same texture, just alias with a 2nd sampler.\n"
//		//"    // This sampler needs to have an exponent bias of -1.\n"
//		"    FxaaTex fxaaConsole360TexExpBiasNegOne,\n"
//		//"    //\n"
//		//"    // Only used on the optimized 360 version of FXAA Console.\n"
//		//"    // For everything but 360, just use the same input here as for \"tex\".\n"
//		//"    // For 360, same texture, just alias with a 3nd sampler.\n"
//		//"    // This sampler needs to have an exponent bias of -2.\n"
//		"    FxaaTex fxaaConsole360TexExpBiasNegTwo,\n"
//		//"    //\n"
//		//"    // Only used on FXAA Quality.\n"
//		//"    // This must be from a constant/uniform.\n"
//		//"    // {x_} = 1.0/screenWidthInPixels\n"
//		//"    // {_y} = 1.0/screenHeightInPixels\n"
//		"    FxaaFloat2 fxaaQualityRcpFrame,\n"
//		//"    //\n"
//		//"    // Only used on FXAA Console.\n"
//		//"    // This must be from a constant/uniform.\n"
//		//"    // This effects sub-pixel AA quality and inversely sharpness.\n"
//		//"    //   Where N ranges between,\n"
//		//"    //     N = 0.50 (default)\n"
//		//"    //     N = 0.33 (sharper)\n"
//		//"    // {x___} = -N/screenWidthInPixels  \n"
//		//"    // {_y__} = -N/screenHeightInPixels\n"
//		//"    // {__z_} =  N/screenWidthInPixels  \n"
//		//"    // {___w} =  N/screenHeightInPixels \n"
//		"    FxaaFloat4 fxaaConsoleRcpFrameOpt,\n"
//		//"    //\n"
//		//"    // Only used on FXAA Console.\n"
//		//"    // Not used on 360, but used on PS3 and PC.\n"
//		//"    // This must be from a constant/uniform.\n"
//		//"    // {x___} = -2.0/screenWidthInPixels  \n"
//		//"    // {_y__} = -2.0/screenHeightInPixels\n"
//		//"    // {__z_} =  2.0/screenWidthInPixels  \n"
//		//"    // {___w} =  2.0/screenHeightInPixels \n"
//		"    FxaaFloat4 fxaaConsoleRcpFrameOpt2,\n"
//		//"    //\n"
//		//"    // Only used on FXAA Console.\n"
//		//"    // Only used on 360 in place of fxaaConsoleRcpFrameOpt2.\n"
//		//"    // This must be from a constant/uniform.\n"
//		//"    // {x___} =  8.0/screenWidthInPixels  \n"
//		//"    // {_y__} =  8.0/screenHeightInPixels\n"
//		//"    // {__z_} = -4.0/screenWidthInPixels  \n"
//		//"    // {___w} = -4.0/screenHeightInPixels \n"
//		"    FxaaFloat4 fxaaConsole360RcpFrameOpt2,\n"
//		//"    //\n"
//		//"    // Only used on FXAA Quality.\n"
//		//"    // This used to be the FXAA_QUALITY__SUBPIX define.\n"
//		//"    // It is here now to allow easier tuning.\n"
//		//"    // Choose the amount of sub-pixel aliasing removal.\n"
//		//"    // This can effect sharpness.\n"
//		//"    //   1.00 - upper limit (softer)\n"
//		//"    //   0.75 - default amount of filtering\n"
//		//"    //   0.50 - lower limit (sharper, less sub-pixel aliasing removal)\n"
//		//"    //   0.25 - almost off\n"
//		//"    //   0.00 - completely off\n"
//		"    FxaaFloat fxaaQualitySubpix,\n"
//		//"    //\n"
//		//"    // Only used on FXAA Quality.\n"
//		//"    // This used to be the FXAA_QUALITY__EDGE_THRESHOLD define.\n"
//		//"    // It is here now to allow easier tuning.\n"
//		//"    // The minimum amount of local contrast required to apply algorithm.\n"
//		//"    //   0.333 - too little (faster)\n"
//		//"    //   0.250 - low quality\n"
//		//"    //   0.166 - default\n"
//		//"    //   0.125 - high quality \n"
//		//"    //   0.063 - overkill (slower)\n"
//		"    FxaaFloat fxaaQualityEdgeThreshold,\n"
//		//"    //\n"
//		//"    // Only used on FXAA Quality.\n"
//		//"    // This used to be the FXAA_QUALITY__EDGE_THRESHOLD_MIN define.\n"
//		//"    // It is here now to allow easier tuning.\n"
//		//"    // Trims the algorithm from processing darks.\n"
//		//"    //   0.0833 - upper limit (default, the start of visible unfiltered edges)\n"
//		//"    //   0.0625 - high quality (faster)\n"
//		//"    //   0.0312 - visible limit (slower)\n"
//		//"    // Special notes when using FXAA_GREEN_AS_LUMA,\n"
//		//"    //   Likely want to set this to zero.\n"
//		//"    //   As colors that are mostly not-green\n"
//		//"    //   will appear very dark in the green channel!\n"
//		//"    //   Tune by looking at mostly non-green content,\n"
//		//"    //   then start at zero and increase until aliasing is a problem.\n"
//		"    FxaaFloat fxaaQualityEdgeThresholdMin,\n"
//		//"    // \n"
//		//"    // Only used on FXAA Console.\n"
//		//"    // This used to be the FXAA_CONSOLE__EDGE_SHARPNESS define.\n"
//		//"    // It is here now to allow easier tuning.\n"
//		//"    // This does not effect PS3, as this needs to be compiled in.\n"
//		//"    //   Use FXAA_CONSOLE__PS3_EDGE_SHARPNESS for PS3.\n"
//		//"    //   Due to the PS3 being ALU bound,\n"
//		//"    //   there are only three safe values here: 2 and 4 and 8.\n"
//		//"    //   These options use the shaders ability to a free *|/ by 2|4|8.\n"
//		//"    // For all other platforms can be a non-power of two.\n"
//		//"    //   8.0 is sharper (default!!!)\n"
//		//"    //   4.0 is softer\n"
//		//"    //   2.0 is really soft (good only for vector graphics inputs)\n"
//		"    FxaaFloat fxaaConsoleEdgeSharpness,\n"
//		//"    //\n"
//		//"    // Only used on FXAA Console.\n"
//		//"    // This used to be the FXAA_CONSOLE__EDGE_THRESHOLD define.\n"
//		//"    // It is here now to allow easier tuning.\n"
//		//"    // This does not effect PS3, as this needs to be compiled in.\n"
//		//"    //   Use FXAA_CONSOLE__PS3_EDGE_THRESHOLD for PS3.\n"
//		//"    //   Due to the PS3 being ALU bound,\n"
//		//"    //   there are only two safe values here: 1/4 and 1/8.\n"
//		//"    //   These options use the shaders ability to a free *|/ by 2|4|8.\n"
//		//"    // The console setting has a different mapping than the quality setting.\n"
//		//"    // Other platforms can use other values.\n"
//		//"    //   0.125 leaves less aliasing, but is softer (default!!!)\n"
//		//"    //   0.25 leaves more aliasing, and is sharper\n"
//		"    FxaaFloat fxaaConsoleEdgeThreshold,\n"
//		//"    //\n"
//		//"    // Only used on FXAA Console.\n"
//		//"    // This used to be the FXAA_CONSOLE__EDGE_THRESHOLD_MIN define.\n"
//		//"    // It is here now to allow easier tuning.\n"
//		//"    // Trims the algorithm from processing darks.\n"
//		//"    // The console setting has a different mapping than the quality setting.\n"
//		//"    // This only applies when FXAA_EARLY_EXIT is 1.\n"
//		//"    // This does not apply to PS3, \n"
//		//"    // PS3 was simplified to avoid more shader instructions.\n"
//		//"    //   0.06 - faster but more aliasing in darks\n"
//		//"    //   0.05 - default\n"
//		//"    //   0.04 - slower and less aliasing in darks\n"
//		//"    // Special notes when using FXAA_GREEN_AS_LUMA,\n"
//		//"    //   Likely want to set this to zero.\n"
//		//"    //   As colors that are mostly not-green\n"
//		//"    //   will appear very dark in the green channel!\n"
//		//"    //   Tune by looking at mostly non-green content,\n"
//		//"    //   then start at zero and increase until aliasing is a problem.\n"
//		"    FxaaFloat fxaaConsoleEdgeThresholdMin,\n"
//		//"    //    \n"
//		//"    // Extra constants for 360 FXAA Console only.\n"
//		//"    // Use zeros or anything else for other platforms.\n"
//		//"    // These must be in physical constant registers and NOT immedates.\n"
//		//"    // Immedates will result in compiler un-optimizing.\n"
//		//"    // {xyzw} = float4(1.0, -1.0, 0.25, -0.25)\n"
//		"    FxaaFloat4 fxaaConsole360ConstDir\n"
//		") {\n"
//		"/*--------------------------------------------------------------------------*/\n"
//		"    FxaaFloat2 posM;\n"
//		"    posM.x = pos.x;\n"
//		"    posM.y = pos.y;\n"
//		"    #if (FXAA_GATHER4_ALPHA == 1)\n"
//		"        #if (FXAA_DISCARD == 0)\n"
//		"            FxaaFloat4 rgbyM = FxaaTexTop(tex, posM);\n"
//		"            #if (FXAA_GREEN_AS_LUMA == 0)\n"
//		"                #define lumaM rgbyM.w\n"
//		"            #else\n"
//		"                #define lumaM rgbyM.y\n"
//		"            #endif\n"
//		"        #endif\n"
//		"        #if (FXAA_GREEN_AS_LUMA == 0)\n"
//		"            FxaaFloat4 luma4A = FxaaTexAlpha4(tex, posM);\n"
//		"            FxaaFloat4 luma4B = FxaaTexOffAlpha4(tex, posM, FxaaInt2(-1, -1));\n"
//		"        #else\n"
//		"            FxaaFloat4 luma4A = FxaaTexGreen4(tex, posM);\n"
//		"            FxaaFloat4 luma4B = FxaaTexOffGreen4(tex, posM, FxaaInt2(-1, -1));\n"
//		"        #endif\n"
//		"        #if (FXAA_DISCARD == 1)\n"
//		"            #define lumaM luma4A.w\n"
//		"        #endif\n"
//		"        #define lumaE luma4A.z\n"
//		"        #define lumaS luma4A.x\n"
//		"        #define lumaSE luma4A.y\n"
//		"        #define lumaNW luma4B.w\n"
//		"        #define lumaN luma4B.z\n"
//		"        #define lumaW luma4B.x\n"
//		"    #else\n"
//		"        FxaaFloat4 rgbyM = FxaaTexTop(tex, posM);\n"
//		"        #if (FXAA_GREEN_AS_LUMA == 0)\n"
//		"            #define lumaM rgbyM.w\n"
//		"        #else\n"
//		"            #define lumaM rgbyM.y\n"
//		"        #endif\n"
//		"        FxaaFloat lumaS = FxaaLuma(FxaaTexOff(tex, posM, FxaaInt2( 0, 1), fxaaQualityRcpFrame.xy));\n"
//		"        FxaaFloat lumaE = FxaaLuma(FxaaTexOff(tex, posM, FxaaInt2( 1, 0), fxaaQualityRcpFrame.xy));\n"
//		"        FxaaFloat lumaN = FxaaLuma(FxaaTexOff(tex, posM, FxaaInt2( 0,-1), fxaaQualityRcpFrame.xy));\n"
//		"        FxaaFloat lumaW = FxaaLuma(FxaaTexOff(tex, posM, FxaaInt2(-1, 0), fxaaQualityRcpFrame.xy));\n"
//		"    #endif\n"
//		"/*--------------------------------------------------------------------------*/\n"
//		"    FxaaFloat maxSM = max(lumaS, lumaM);\n"
//		"    FxaaFloat minSM = min(lumaS, lumaM);\n"
//		"    FxaaFloat maxESM = max(lumaE, maxSM);\n"
//		"    FxaaFloat minESM = min(lumaE, minSM);\n"
//		"    FxaaFloat maxWN = max(lumaN, lumaW);\n"
//		"    FxaaFloat minWN = min(lumaN, lumaW);\n"
//		"    FxaaFloat rangeMax = max(maxWN, maxESM);\n"
//		"    FxaaFloat rangeMin = min(minWN, minESM);\n"
//		"    FxaaFloat rangeMaxScaled = rangeMax * fxaaQualityEdgeThreshold;\n"
//		"    FxaaFloat range = rangeMax - rangeMin;\n"
//		"    FxaaFloat rangeMaxClamped = max(fxaaQualityEdgeThresholdMin, rangeMaxScaled);\n"
//		"    FxaaBool earlyExit = range < rangeMaxClamped;\n"
//		"/*--------------------------------------------------------------------------*/\n"
//		"    if(earlyExit)\n"
//		"        #if (FXAA_DISCARD == 1)\n"
//		"            FxaaDiscard;\n"
//		"        #else\n"
//		"            return rgbyM;\n"
//		"        #endif\n"
//		"/*--------------------------------------------------------------------------*/\n"
//		"    #if (FXAA_GATHER4_ALPHA == 0)\n"
//		"        FxaaFloat lumaNW = FxaaLuma(FxaaTexOff(tex, posM, FxaaInt2(-1,-1), fxaaQualityRcpFrame.xy));\n"
//		"        FxaaFloat lumaSE = FxaaLuma(FxaaTexOff(tex, posM, FxaaInt2( 1, 1), fxaaQualityRcpFrame.xy));\n"
//		"        FxaaFloat lumaNE = FxaaLuma(FxaaTexOff(tex, posM, FxaaInt2( 1,-1), fxaaQualityRcpFrame.xy));\n"
//		"        FxaaFloat lumaSW = FxaaLuma(FxaaTexOff(tex, posM, FxaaInt2(-1, 1), fxaaQualityRcpFrame.xy));\n"
//		"    #else\n"
//		"        FxaaFloat lumaNE = FxaaLuma(FxaaTexOff(tex, posM, FxaaInt2(1, -1), fxaaQualityRcpFrame.xy));\n"
//		"        FxaaFloat lumaSW = FxaaLuma(FxaaTexOff(tex, posM, FxaaInt2(-1, 1), fxaaQualityRcpFrame.xy));\n"
//		"    #endif\n"
//		"/*--------------------------------------------------------------------------*/\n"
//		"    FxaaFloat lumaNS = lumaN + lumaS;\n"
//		"    FxaaFloat lumaWE = lumaW + lumaE;\n"
//		"    FxaaFloat subpixRcpRange = 1.0/range;\n"
//		"    FxaaFloat subpixNSWE = lumaNS + lumaWE;\n"
//		"    FxaaFloat edgeHorz1 = (-2.0 * lumaM) + lumaNS;\n"
//		"    FxaaFloat edgeVert1 = (-2.0 * lumaM) + lumaWE;\n"
//		"/*--------------------------------------------------------------------------*/\n"
//		"    FxaaFloat lumaNESE = lumaNE + lumaSE;\n"
//		"    FxaaFloat lumaNWNE = lumaNW + lumaNE;\n"
//		"    FxaaFloat edgeHorz2 = (-2.0 * lumaE) + lumaNESE;\n"
//		"    FxaaFloat edgeVert2 = (-2.0 * lumaN) + lumaNWNE;\n"
//		"/*--------------------------------------------------------------------------*/\n"
//		"    FxaaFloat lumaNWSW = lumaNW + lumaSW;\n"
//		"    FxaaFloat lumaSWSE = lumaSW + lumaSE;\n"
//		"    FxaaFloat edgeHorz4 = (abs(edgeHorz1) * 2.0) + abs(edgeHorz2);\n"
//		"    FxaaFloat edgeVert4 = (abs(edgeVert1) * 2.0) + abs(edgeVert2);\n"
//		"    FxaaFloat edgeHorz3 = (-2.0 * lumaW) + lumaNWSW;\n"
//		"    FxaaFloat edgeVert3 = (-2.0 * lumaS) + lumaSWSE;\n"
//		"    FxaaFloat edgeHorz = abs(edgeHorz3) + edgeHorz4;\n"
//		"    FxaaFloat edgeVert = abs(edgeVert3) + edgeVert4;\n"
//		"/*--------------------------------------------------------------------------*/\n"
//		"    FxaaFloat subpixNWSWNESE = lumaNWSW + lumaNESE;\n"
//		"    FxaaFloat lengthSign = fxaaQualityRcpFrame.x;\n"
//		"    FxaaBool horzSpan = edgeHorz >= edgeVert;\n"
//		"    FxaaFloat subpixA = subpixNSWE * 2.0 + subpixNWSWNESE;\n"
//		"/*--------------------------------------------------------------------------*/\n"
//		"    if(!horzSpan) lumaN = lumaW;\n"
//		"    if(!horzSpan) lumaS = lumaE;\n"
//		"    if(horzSpan) lengthSign = fxaaQualityRcpFrame.y;\n"
//		"    FxaaFloat subpixB = (subpixA * (1.0/12.0)) - lumaM;\n"
//		"/*--------------------------------------------------------------------------*/\n"
//		"    FxaaFloat gradientN = lumaN - lumaM;\n"
//		"    FxaaFloat gradientS = lumaS - lumaM;\n"
//		"    FxaaFloat lumaNN = lumaN + lumaM;\n"
//		"    FxaaFloat lumaSS = lumaS + lumaM;\n"
//		"    FxaaBool pairN = abs(gradientN) >= abs(gradientS);\n"
//		"    FxaaFloat gradient = max(abs(gradientN), abs(gradientS));\n"
//		"    if(pairN) lengthSign = -lengthSign;\n"
//		"    FxaaFloat subpixC = FxaaSat(abs(subpixB) * subpixRcpRange);\n"
//		"/*--------------------------------------------------------------------------*/\n"
//		"    FxaaFloat2 posB;\n"
//		"    posB.x = posM.x;\n"
//		"    posB.y = posM.y;\n"
//		"    FxaaFloat2 offNP;\n"
//		"    offNP.x = (!horzSpan) ? 0.0 : fxaaQualityRcpFrame.x;\n"
//		"    offNP.y = ( horzSpan) ? 0.0 : fxaaQualityRcpFrame.y;\n"
//		"    if(!horzSpan) posB.x += lengthSign * 0.5;\n"
//		"    if( horzSpan) posB.y += lengthSign * 0.5;\n"
//		"/*--------------------------------------------------------------------------*/\n"
//		"    FxaaFloat2 posN;\n"
//		"    posN.x = posB.x - offNP.x * FXAA_QUALITY__P0;\n"
//		"    posN.y = posB.y - offNP.y * FXAA_QUALITY__P0;\n"
//		"    FxaaFloat2 posP;\n"
//		"    posP.x = posB.x + offNP.x * FXAA_QUALITY__P0;\n"
//		"    posP.y = posB.y + offNP.y * FXAA_QUALITY__P0;\n"
//		"    FxaaFloat subpixD = ((-2.0)*subpixC) + 3.0;\n"
//		"    FxaaFloat lumaEndN = FxaaLuma(FxaaTexTop(tex, posN));\n"
//		"    FxaaFloat subpixE = subpixC * subpixC;\n"
//		"    FxaaFloat lumaEndP = FxaaLuma(FxaaTexTop(tex, posP));\n"
//		"/*--------------------------------------------------------------------------*/\n"
//		"    if(!pairN) lumaNN = lumaSS;\n"
//		"    FxaaFloat gradientScaled = gradient * 1.0/4.0;\n"
//		"    FxaaFloat lumaMM = lumaM - lumaNN * 0.5;\n"
//		"    FxaaFloat subpixF = subpixD * subpixE;\n"
//		"    FxaaBool lumaMLTZero = lumaMM < 0.0;\n"
//		"/*--------------------------------------------------------------------------*/\n"
//		"    lumaEndN -= lumaNN * 0.5;\n"
//		"    lumaEndP -= lumaNN * 0.5;\n"
//		"    FxaaBool doneN = abs(lumaEndN) >= gradientScaled;\n"
//		"    FxaaBool doneP = abs(lumaEndP) >= gradientScaled;\n"
//		"    if(!doneN) posN.x -= offNP.x * FXAA_QUALITY__P1;\n"
//		"    if(!doneN) posN.y -= offNP.y * FXAA_QUALITY__P1;\n"
//		"    FxaaBool doneNP = (!doneN) || (!doneP);\n"
//		"    if(!doneP) posP.x += offNP.x * FXAA_QUALITY__P1;\n"
//		"    if(!doneP) posP.y += offNP.y * FXAA_QUALITY__P1;\n"
//		"/*--------------------------------------------------------------------------*/\n"
//		"    if(doneNP) {\n"
//		"        if(!doneN) lumaEndN = FxaaLuma(FxaaTexTop(tex, posN.xy));\n"
//		"        if(!doneP) lumaEndP = FxaaLuma(FxaaTexTop(tex, posP.xy));\n"
//		"        if(!doneN) lumaEndN = lumaEndN - lumaNN * 0.5;\n"
//		"        if(!doneP) lumaEndP = lumaEndP - lumaNN * 0.5;\n"
//		"        doneN = abs(lumaEndN) >= gradientScaled;\n"
//		"        doneP = abs(lumaEndP) >= gradientScaled;\n"
//		"        if(!doneN) posN.x -= offNP.x * FXAA_QUALITY__P2;\n"
//		"        if(!doneN) posN.y -= offNP.y * FXAA_QUALITY__P2;\n"
//		"        doneNP = (!doneN) || (!doneP);\n"
//		"        if(!doneP) posP.x += offNP.x * FXAA_QUALITY__P2;\n"
//		"        if(!doneP) posP.y += offNP.y * FXAA_QUALITY__P2;\n"
//		"/*--------------------------------------------------------------------------*/\n"
//		"        #if (FXAA_QUALITY__PS > 3)\n"
//		"        if(doneNP) {\n"
//		"            if(!doneN) lumaEndN = FxaaLuma(FxaaTexTop(tex, posN.xy));\n"
//		"            if(!doneP) lumaEndP = FxaaLuma(FxaaTexTop(tex, posP.xy));\n"
//		"            if(!doneN) lumaEndN = lumaEndN - lumaNN * 0.5;\n"
//		"            if(!doneP) lumaEndP = lumaEndP - lumaNN * 0.5;\n"
//		"            doneN = abs(lumaEndN) >= gradientScaled;\n"
//		"            doneP = abs(lumaEndP) >= gradientScaled;\n"
//		"            if(!doneN) posN.x -= offNP.x * FXAA_QUALITY__P3;\n"
//		"            if(!doneN) posN.y -= offNP.y * FXAA_QUALITY__P3;\n"
//		"            doneNP = (!doneN) || (!doneP);\n"
//		"            if(!doneP) posP.x += offNP.x * FXAA_QUALITY__P3;\n"
//		"            if(!doneP) posP.y += offNP.y * FXAA_QUALITY__P3;\n"
//		"/*--------------------------------------------------------------------------*/\n"
//		"            #if (FXAA_QUALITY__PS > 4)\n"
//		"            if(doneNP) {\n"
//		"                if(!doneN) lumaEndN = FxaaLuma(FxaaTexTop(tex, posN.xy));\n"
//		"                if(!doneP) lumaEndP = FxaaLuma(FxaaTexTop(tex, posP.xy));\n"
//		"                if(!doneN) lumaEndN = lumaEndN - lumaNN * 0.5;\n"
//		"                if(!doneP) lumaEndP = lumaEndP - lumaNN * 0.5;\n"
//		"                doneN = abs(lumaEndN) >= gradientScaled;\n"
//		"                doneP = abs(lumaEndP) >= gradientScaled;\n"
//		"                if(!doneN) posN.x -= offNP.x * FXAA_QUALITY__P4;\n"
//		"                if(!doneN) posN.y -= offNP.y * FXAA_QUALITY__P4;\n"
//		"                doneNP = (!doneN) || (!doneP);\n"
//		"                if(!doneP) posP.x += offNP.x * FXAA_QUALITY__P4;\n"
//		"                if(!doneP) posP.y += offNP.y * FXAA_QUALITY__P4;\n"
//		"/*--------------------------------------------------------------------------*/\n"
//		"                #if (FXAA_QUALITY__PS > 5)\n"
//		"                if(doneNP) {\n"
//		"                    if(!doneN) lumaEndN = FxaaLuma(FxaaTexTop(tex, posN.xy));\n"
//		"                    if(!doneP) lumaEndP = FxaaLuma(FxaaTexTop(tex, posP.xy));\n"
//		"                    if(!doneN) lumaEndN = lumaEndN - lumaNN * 0.5;\n"
//		"                    if(!doneP) lumaEndP = lumaEndP - lumaNN * 0.5;\n"
//		"                    doneN = abs(lumaEndN) >= gradientScaled;\n"
//		"                    doneP = abs(lumaEndP) >= gradientScaled;\n"
//		"                    if(!doneN) posN.x -= offNP.x * FXAA_QUALITY__P5;\n"
//		"                    if(!doneN) posN.y -= offNP.y * FXAA_QUALITY__P5;\n"
//		"                    doneNP = (!doneN) || (!doneP);\n"
//		"                    if(!doneP) posP.x += offNP.x * FXAA_QUALITY__P5;\n"
//		"                    if(!doneP) posP.y += offNP.y * FXAA_QUALITY__P5;\n"
//		"/*--------------------------------------------------------------------------*/\n"
//		"                    #if (FXAA_QUALITY__PS > 6)\n"
//		"                    if(doneNP) {\n"
//		"                        if(!doneN) lumaEndN = FxaaLuma(FxaaTexTop(tex, posN.xy));\n"
//		"                        if(!doneP) lumaEndP = FxaaLuma(FxaaTexTop(tex, posP.xy));\n"
//		"                        if(!doneN) lumaEndN = lumaEndN - lumaNN * 0.5;\n"
//		"                        if(!doneP) lumaEndP = lumaEndP - lumaNN * 0.5;\n"
//		"                        doneN = abs(lumaEndN) >= gradientScaled;\n"
//		"                        doneP = abs(lumaEndP) >= gradientScaled;\n"
//		"                        if(!doneN) posN.x -= offNP.x * FXAA_QUALITY__P6;\n"
//		"                        if(!doneN) posN.y -= offNP.y * FXAA_QUALITY__P6;\n"
//		"                        doneNP = (!doneN) || (!doneP);\n"
//		"                        if(!doneP) posP.x += offNP.x * FXAA_QUALITY__P6;\n"
//		"                        if(!doneP) posP.y += offNP.y * FXAA_QUALITY__P6;\n"
//		"/*--------------------------------------------------------------------------*/\n"
//		"                        #if (FXAA_QUALITY__PS > 7)\n"
//		"                        if(doneNP) {\n"
//		"                            if(!doneN) lumaEndN = FxaaLuma(FxaaTexTop(tex, posN.xy));\n"
//		"                            if(!doneP) lumaEndP = FxaaLuma(FxaaTexTop(tex, posP.xy));\n"
//		"                            if(!doneN) lumaEndN = lumaEndN - lumaNN * 0.5;\n"
//		"                            if(!doneP) lumaEndP = lumaEndP - lumaNN * 0.5;\n"
//		"                            doneN = abs(lumaEndN) >= gradientScaled;\n"
//		"                            doneP = abs(lumaEndP) >= gradientScaled;\n"
//		"                            if(!doneN) posN.x -= offNP.x * FXAA_QUALITY__P7;\n"
//		"                            if(!doneN) posN.y -= offNP.y * FXAA_QUALITY__P7;\n"
//		"                            doneNP = (!doneN) || (!doneP);\n"
//		"                            if(!doneP) posP.x += offNP.x * FXAA_QUALITY__P7;\n"
//		"                            if(!doneP) posP.y += offNP.y * FXAA_QUALITY__P7;\n"
//		"/*--------------------------------------------------------------------------*/\n"
//		"    #if (FXAA_QUALITY__PS > 8)\n"
//		"    if(doneNP) {\n"
//		"        if(!doneN) lumaEndN = FxaaLuma(FxaaTexTop(tex, posN.xy));\n"
//		"        if(!doneP) lumaEndP = FxaaLuma(FxaaTexTop(tex, posP.xy));\n"
//		"        if(!doneN) lumaEndN = lumaEndN - lumaNN * 0.5;\n"
//		"        if(!doneP) lumaEndP = lumaEndP - lumaNN * 0.5;\n"
//		"        doneN = abs(lumaEndN) >= gradientScaled;\n"
//		"        doneP = abs(lumaEndP) >= gradientScaled;\n"
//		"        if(!doneN) posN.x -= offNP.x * FXAA_QUALITY__P8;\n"
//		"        if(!doneN) posN.y -= offNP.y * FXAA_QUALITY__P8;\n"
//		"        doneNP = (!doneN) || (!doneP);\n"
//		"        if(!doneP) posP.x += offNP.x * FXAA_QUALITY__P8;\n"
//		"        if(!doneP) posP.y += offNP.y * FXAA_QUALITY__P8;\n"
//		"/*--------------------------------------------------------------------------*/\n"
//		"        #if (FXAA_QUALITY__PS > 9)\n"
//		"        if(doneNP) {\n"
//		"            if(!doneN) lumaEndN = FxaaLuma(FxaaTexTop(tex, posN.xy));\n"
//		"            if(!doneP) lumaEndP = FxaaLuma(FxaaTexTop(tex, posP.xy));\n"
//		"            if(!doneN) lumaEndN = lumaEndN - lumaNN * 0.5;\n"
//		"            if(!doneP) lumaEndP = lumaEndP - lumaNN * 0.5;\n"
//		"            doneN = abs(lumaEndN) >= gradientScaled;\n"
//		"            doneP = abs(lumaEndP) >= gradientScaled;\n"
//		"            if(!doneN) posN.x -= offNP.x * FXAA_QUALITY__P9;\n"
//		"            if(!doneN) posN.y -= offNP.y * FXAA_QUALITY__P9;\n"
//		"            doneNP = (!doneN) || (!doneP);\n"
//		"            if(!doneP) posP.x += offNP.x * FXAA_QUALITY__P9;\n"
//		"            if(!doneP) posP.y += offNP.y * FXAA_QUALITY__P9;\n"
//		"/*--------------------------------------------------------------------------*/\n"
//		"            #if (FXAA_QUALITY__PS > 10)\n"
//		"            if(doneNP) {\n"
//		"                if(!doneN) lumaEndN = FxaaLuma(FxaaTexTop(tex, posN.xy));\n"
//		"                if(!doneP) lumaEndP = FxaaLuma(FxaaTexTop(tex, posP.xy));\n"
//		"                if(!doneN) lumaEndN = lumaEndN - lumaNN * 0.5;\n"
//		"                if(!doneP) lumaEndP = lumaEndP - lumaNN * 0.5;\n"
//		"                doneN = abs(lumaEndN) >= gradientScaled;\n"
//		"                doneP = abs(lumaEndP) >= gradientScaled;\n"
//		"                if(!doneN) posN.x -= offNP.x * FXAA_QUALITY__P10;\n"
//		"                if(!doneN) posN.y -= offNP.y * FXAA_QUALITY__P10;\n"
//		"                doneNP = (!doneN) || (!doneP);\n"
//		"                if(!doneP) posP.x += offNP.x * FXAA_QUALITY__P10;\n"
//		"                if(!doneP) posP.y += offNP.y * FXAA_QUALITY__P10;\n"
//		"/*--------------------------------------------------------------------------*/\n"
//		"                #if (FXAA_QUALITY__PS > 11)\n"
//		"                if(doneNP) {\n"
//		"                    if(!doneN) lumaEndN = FxaaLuma(FxaaTexTop(tex, posN.xy));\n"
//		"                    if(!doneP) lumaEndP = FxaaLuma(FxaaTexTop(tex, posP.xy));\n"
//		"                    if(!doneN) lumaEndN = lumaEndN - lumaNN * 0.5;\n"
//		"                    if(!doneP) lumaEndP = lumaEndP - lumaNN * 0.5;\n"
//		"                    doneN = abs(lumaEndN) >= gradientScaled;\n"
//		"                    doneP = abs(lumaEndP) >= gradientScaled;\n"
//		"                    if(!doneN) posN.x -= offNP.x * FXAA_QUALITY__P11;\n"
//		"                    if(!doneN) posN.y -= offNP.y * FXAA_QUALITY__P11;\n"
//		"                    doneNP = (!doneN) || (!doneP);\n"
//		"                    if(!doneP) posP.x += offNP.x * FXAA_QUALITY__P11;\n"
//		"                    if(!doneP) posP.y += offNP.y * FXAA_QUALITY__P11;\n"
//		"/*--------------------------------------------------------------------------*/\n"
//		"                    #if (FXAA_QUALITY__PS > 12)\n"
//		"                    if(doneNP) {\n"
//		"                        if(!doneN) lumaEndN = FxaaLuma(FxaaTexTop(tex, posN.xy));\n"
//		"                        if(!doneP) lumaEndP = FxaaLuma(FxaaTexTop(tex, posP.xy));\n"
//		"                        if(!doneN) lumaEndN = lumaEndN - lumaNN * 0.5;\n"
//		"                        if(!doneP) lumaEndP = lumaEndP - lumaNN * 0.5;\n"
//		"                        doneN = abs(lumaEndN) >= gradientScaled;\n"
//		"                        doneP = abs(lumaEndP) >= gradientScaled;\n"
//		"                        if(!doneN) posN.x -= offNP.x * FXAA_QUALITY__P12;\n"
//		"                        if(!doneN) posN.y -= offNP.y * FXAA_QUALITY__P12;\n"
//		"                        doneNP = (!doneN) || (!doneP);\n"
//		"                        if(!doneP) posP.x += offNP.x * FXAA_QUALITY__P12;\n"
//		"                        if(!doneP) posP.y += offNP.y * FXAA_QUALITY__P12;\n"
//		"/*--------------------------------------------------------------------------*/\n"
//		"                    }\n"
//		"                    #endif\n"
//		"/*--------------------------------------------------------------------------*/\n"
//		"                }\n"
//		"                #endif\n"
//		"/*--------------------------------------------------------------------------*/\n"
//		"            }\n"
//		"            #endif\n"
//		"/*--------------------------------------------------------------------------*/\n"
//		"        }\n"
//		"        #endif\n"
//		"/*--------------------------------------------------------------------------*/\n"
//		"    }\n"
//		"    #endif\n"
//		"/*--------------------------------------------------------------------------*/\n"
//		"                        }\n"
//		"                        #endif\n"
//		"/*--------------------------------------------------------------------------*/\n"
//		"                    }\n"
//		"                    #endif\n"
//		"/*--------------------------------------------------------------------------*/\n"
//		"                }\n"
//		"                #endif\n"
//		"/*--------------------------------------------------------------------------*/\n"
//		"            }\n"
//		"            #endif\n"
//		"/*--------------------------------------------------------------------------*/\n"
//		"        }\n"
//		"        #endif\n"
//		"/*--------------------------------------------------------------------------*/\n"
//		"    }\n"
//		"/*--------------------------------------------------------------------------*/\n"
//		"    FxaaFloat dstN = posM.x - posN.x;\n"
//		"    FxaaFloat dstP = posP.x - posM.x;\n"
//		"    if(!horzSpan) dstN = posM.y - posN.y;\n"
//		"    if(!horzSpan) dstP = posP.y - posM.y;\n"
//		"/*--------------------------------------------------------------------------*/\n"
//		"    FxaaBool goodSpanN = (lumaEndN < 0.0) != lumaMLTZero;\n"
//		"    FxaaFloat spanLength = (dstP + dstN);\n"
//		"    FxaaBool goodSpanP = (lumaEndP < 0.0) != lumaMLTZero;\n"
//		"    FxaaFloat spanLengthRcp = 1.0/spanLength;\n"
//		"/*--------------------------------------------------------------------------*/\n"
//		"    FxaaBool directionN = dstN < dstP;\n"
//		"    FxaaFloat dst = min(dstN, dstP);\n"
//		"    FxaaBool goodSpan = directionN ? goodSpanN : goodSpanP;\n"
//		"    FxaaFloat subpixG = subpixF * subpixF;\n"
//		"    FxaaFloat pixelOffset = (dst * (-spanLengthRcp)) + 0.5;\n"
//		"    FxaaFloat subpixH = subpixG * fxaaQualitySubpix;\n"
//		"/*--------------------------------------------------------------------------*/\n"
//		"    FxaaFloat pixelOffsetGood = goodSpan ? pixelOffset : 0.0;\n"
//		"    FxaaFloat pixelOffsetSubpix = max(pixelOffsetGood, subpixH);\n"
//		"    if(!horzSpan) posM.x += pixelOffsetSubpix * lengthSign;\n"
//		"    if( horzSpan) posM.y += pixelOffsetSubpix * lengthSign;\n"
//		"    #if (FXAA_DISCARD == 1)\n"
//		"        return FxaaTexTop(tex, posM);\n"
//		"    #else\n"
//		"        return FxaaFloat4(FxaaTexTop(tex, posM).xyz, lumaM);\n"
//		"    #endif\n"
//		"}\n"
//		"/*==========================================================================*/\n"
//		"#endif\n"
//		"\n"
//		"\n"
//		"\n"
//		"\n"
//		"/*============================================================================\n"
//		"\n"
//		"                         FXAA3 CONSOLE - PC VERSION\n"
//		"                         \n"
//		"------------------------------------------------------------------------------\n"
//		"Instead of using this on PC, I'd suggest just using FXAA Quality with\n"
//		"    #define FXAA_QUALITY__PRESET 10\n"
//		"Or \n"
//		"    #define FXAA_QUALITY__PRESET 20\n"
//		"Either are higher qualilty and almost as fast as this on modern PC GPUs.\n"
//		"============================================================================*/\n"
//		"#if (FXAA_PC_CONSOLE == 1)\n"
//		"/*--------------------------------------------------------------------------*/\n"
//		"FxaaFloat4 FxaaPixelShader(\n"
//		"    // See FXAA Quality FxaaPixelShader() source for docs on Inputs!\n"
//		"    FxaaFloat2 pos,\n"
//		"    FxaaFloat4 fxaaConsolePosPos,\n"
//		"    FxaaTex tex,\n"
//		"    FxaaTex fxaaConsole360TexExpBiasNegOne,\n"
//		"    FxaaTex fxaaConsole360TexExpBiasNegTwo,\n"
//		"    FxaaFloat2 fxaaQualityRcpFrame,\n"
//		"    FxaaFloat4 fxaaConsoleRcpFrameOpt,\n"
//		"    FxaaFloat4 fxaaConsoleRcpFrameOpt2,\n"
//		"    FxaaFloat4 fxaaConsole360RcpFrameOpt2,\n"
//		"    FxaaFloat fxaaQualitySubpix,\n"
//		"    FxaaFloat fxaaQualityEdgeThreshold,\n"
//		"    FxaaFloat fxaaQualityEdgeThresholdMin,\n"
//		"    FxaaFloat fxaaConsoleEdgeSharpness,\n"
//		"    FxaaFloat fxaaConsoleEdgeThreshold,\n"
//		"    FxaaFloat fxaaConsoleEdgeThresholdMin,\n"
//		"    FxaaFloat4 fxaaConsole360ConstDir\n"
//		") {\n"
//		"/*--------------------------------------------------------------------------*/\n"
//		"    FxaaFloat lumaNw = FxaaLuma(FxaaTexTop(tex, fxaaConsolePosPos.xy));\n"
//		"    FxaaFloat lumaSw = FxaaLuma(FxaaTexTop(tex, fxaaConsolePosPos.xw));\n"
//		"    FxaaFloat lumaNe = FxaaLuma(FxaaTexTop(tex, fxaaConsolePosPos.zy));\n"
//		"    FxaaFloat lumaSe = FxaaLuma(FxaaTexTop(tex, fxaaConsolePosPos.zw));\n"
//		"/*--------------------------------------------------------------------------*/\n"
//		"    FxaaFloat4 rgbyM = FxaaTexTop(tex, pos.xy);\n"
//		"    #if (FXAA_GREEN_AS_LUMA == 0)\n"
//		"        FxaaFloat lumaM = rgbyM.w;\n"
//		"    #else\n"
//		"        FxaaFloat lumaM = rgbyM.y;\n"
//		"    #endif\n"
//		"/*--------------------------------------------------------------------------*/\n"
//		"    FxaaFloat lumaMaxNwSw = max(lumaNw, lumaSw);\n"
//		"    lumaNe += 1.0/384.0;\n"
//		"    FxaaFloat lumaMinNwSw = min(lumaNw, lumaSw);\n"
//		"/*--------------------------------------------------------------------------*/\n"
//		"    FxaaFloat lumaMaxNeSe = max(lumaNe, lumaSe);\n"
//		"    FxaaFloat lumaMinNeSe = min(lumaNe, lumaSe);\n"
//		"/*--------------------------------------------------------------------------*/\n"
//		"    FxaaFloat lumaMax = max(lumaMaxNeSe, lumaMaxNwSw);\n"
//		"    FxaaFloat lumaMin = min(lumaMinNeSe, lumaMinNwSw);\n"
//		"/*--------------------------------------------------------------------------*/\n"
//		"    FxaaFloat lumaMaxScaled = lumaMax * fxaaConsoleEdgeThreshold;\n"
//		"/*--------------------------------------------------------------------------*/\n"
//		"    FxaaFloat lumaMinM = min(lumaMin, lumaM);\n"
//		"    FxaaFloat lumaMaxScaledClamped = max(fxaaConsoleEdgeThresholdMin, lumaMaxScaled);\n"
//		"    FxaaFloat lumaMaxM = max(lumaMax, lumaM);\n"
//		"    FxaaFloat dirSwMinusNe = lumaSw - lumaNe;\n"
//		"    FxaaFloat lumaMaxSubMinM = lumaMaxM - lumaMinM;\n"
//		"    FxaaFloat dirSeMinusNw = lumaSe - lumaNw;\n"
//		"    if(lumaMaxSubMinM < lumaMaxScaledClamped) return rgbyM;\n"
//		"/*--------------------------------------------------------------------------*/\n"
//		"    FxaaFloat2 dir;\n"
//		"    dir.x = dirSwMinusNe + dirSeMinusNw;\n"
//		"    dir.y = dirSwMinusNe - dirSeMinusNw;\n"
//		"/*--------------------------------------------------------------------------*/\n"
//		"    FxaaFloat2 dir1 = normalize(dir.xy);\n"
//		"    FxaaFloat4 rgbyN1 = FxaaTexTop(tex, pos.xy - dir1 * fxaaConsoleRcpFrameOpt.zw);\n"
//		"    FxaaFloat4 rgbyP1 = FxaaTexTop(tex, pos.xy + dir1 * fxaaConsoleRcpFrameOpt.zw);\n"
//		"/*--------------------------------------------------------------------------*/\n"
//		"    FxaaFloat dirAbsMinTimesC = min(abs(dir1.x), abs(dir1.y)) * fxaaConsoleEdgeSharpness;\n"
//		"    FxaaFloat2 dir2 = clamp(dir1.xy / dirAbsMinTimesC, -2.0, 2.0);\n"
//		"/*--------------------------------------------------------------------------*/\n"
//		"    FxaaFloat4 rgbyN2 = FxaaTexTop(tex, pos.xy - dir2 * fxaaConsoleRcpFrameOpt2.zw);\n"
//		"    FxaaFloat4 rgbyP2 = FxaaTexTop(tex, pos.xy + dir2 * fxaaConsoleRcpFrameOpt2.zw);\n"
//		"/*--------------------------------------------------------------------------*/\n"
//		"    FxaaFloat4 rgbyA = rgbyN1 + rgbyP1;\n"
//		"    FxaaFloat4 rgbyB = ((rgbyN2 + rgbyP2) * 0.25) + (rgbyA * 0.25);\n"
//		"/*--------------------------------------------------------------------------*/\n"
//		"    #if (FXAA_GREEN_AS_LUMA == 0)\n"
//		"        FxaaBool twoTap = (rgbyB.w < lumaMin) || (rgbyB.w > lumaMax);\n"
//		"    #else\n"
//		"        FxaaBool twoTap = (rgbyB.y < lumaMin) || (rgbyB.y > lumaMax);\n"
//		"    #endif\n"
//		"    if(twoTap) rgbyB.xyz = rgbyA.xyz * 0.5;\n"
//		"    return rgbyB; }\n"
//		"/*==========================================================================*/\n"
//		"#endif\n"
//		"\n"
//		"\n"
//		"\n"
//		"/*============================================================================\n"
//		"\n"
//		"                      FXAA3 CONSOLE - 360 PIXEL SHADER \n"
//		"\n"
//		"------------------------------------------------------------------------------\n"
//		"This optimized version thanks to suggestions from Andy Luedke.\n"
//		"Should be fully tex bound in all cases.\n"
//		"As of the FXAA 3.11 release, I have still not tested this code,\n"
//		"however I fixed a bug which was in both FXAA 3.9 and FXAA 3.10.\n"
//		"And note this is replacing the old unoptimized version.\n"
//		"If it does not work, please let me know so I can fix it.\n"
//		"============================================================================*/\n"
//		"#if (FXAA_360 == 1)\n"
//		"/*--------------------------------------------------------------------------*/\n"
//		"[reduceTempRegUsage(4)]\n"
//		"float4 FxaaPixelShader(\n"
//		"    // See FXAA Quality FxaaPixelShader() source for docs on Inputs!\n"
//		"    FxaaFloat2 pos,\n"
//		"    FxaaFloat4 fxaaConsolePosPos,\n"
//		"    FxaaTex tex,\n"
//		"    FxaaTex fxaaConsole360TexExpBiasNegOne,\n"
//		"    FxaaTex fxaaConsole360TexExpBiasNegTwo,\n"
//		"    FxaaFloat2 fxaaQualityRcpFrame,\n"
//		"    FxaaFloat4 fxaaConsoleRcpFrameOpt,\n"
//		"    FxaaFloat4 fxaaConsoleRcpFrameOpt2,\n"
//		"    FxaaFloat4 fxaaConsole360RcpFrameOpt2,\n"
//		"    FxaaFloat fxaaQualitySubpix,\n"
//		"    FxaaFloat fxaaQualityEdgeThreshold,\n"
//		"    FxaaFloat fxaaQualityEdgeThresholdMin,\n"
//		"    FxaaFloat fxaaConsoleEdgeSharpness,\n"
//		"    FxaaFloat fxaaConsoleEdgeThreshold,\n"
//		"    FxaaFloat fxaaConsoleEdgeThresholdMin,\n"
//		"    FxaaFloat4 fxaaConsole360ConstDir\n"
//		") {\n"
//		"/*--------------------------------------------------------------------------*/\n"
//		"    float4 lumaNwNeSwSe;\n"
//		"    #if (FXAA_GREEN_AS_LUMA == 0)\n"
//		"        asm { \n"
//		"            tfetch2D lumaNwNeSwSe.w___, tex, pos.xy, OffsetX = -0.5, OffsetY = -0.5, UseComputedLOD=false\n"
//		"            tfetch2D lumaNwNeSwSe._w__, tex, pos.xy, OffsetX =  0.5, OffsetY = -0.5, UseComputedLOD=false\n"
//		"            tfetch2D lumaNwNeSwSe.__w_, tex, pos.xy, OffsetX = -0.5, OffsetY =  0.5, UseComputedLOD=false\n"
//		"            tfetch2D lumaNwNeSwSe.___w, tex, pos.xy, OffsetX =  0.5, OffsetY =  0.5, UseComputedLOD=false\n"
//		"        };\n"
//		"    #else\n"
//		"        asm { \n"
//		"            tfetch2D lumaNwNeSwSe.y___, tex, pos.xy, OffsetX = -0.5, OffsetY = -0.5, UseComputedLOD=false\n"
//		"            tfetch2D lumaNwNeSwSe._y__, tex, pos.xy, OffsetX =  0.5, OffsetY = -0.5, UseComputedLOD=false\n"
//		"            tfetch2D lumaNwNeSwSe.__y_, tex, pos.xy, OffsetX = -0.5, OffsetY =  0.5, UseComputedLOD=false\n"
//		"            tfetch2D lumaNwNeSwSe.___y, tex, pos.xy, OffsetX =  0.5, OffsetY =  0.5, UseComputedLOD=false\n"
//		"        };\n"
//		"    #endif\n"
//		"/*--------------------------------------------------------------------------*/\n"
//		"    lumaNwNeSwSe.y += 1.0/384.0;\n"
//		"    float2 lumaMinTemp = min(lumaNwNeSwSe.xy, lumaNwNeSwSe.zw);\n"
//		"    float2 lumaMaxTemp = max(lumaNwNeSwSe.xy, lumaNwNeSwSe.zw);\n"
//		"    float lumaMin = min(lumaMinTemp.x, lumaMinTemp.y);\n"
//		"    float lumaMax = max(lumaMaxTemp.x, lumaMaxTemp.y);\n"
//		"/*--------------------------------------------------------------------------*/\n"
//		"    float4 rgbyM = tex2Dlod(tex, float4(pos.xy, 0.0, 0.0));\n"
//		"    #if (FXAA_GREEN_AS_LUMA == 0)\n"
//		"        float lumaMinM = min(lumaMin, rgbyM.w);\n"
//		"        float lumaMaxM = max(lumaMax, rgbyM.w);\n"
//		"    #else\n"
//		"        float lumaMinM = min(lumaMin, rgbyM.y);\n"
//		"        float lumaMaxM = max(lumaMax, rgbyM.y);\n"
//		"    #endif        \n"
//		"    if((lumaMaxM - lumaMinM) < max(fxaaConsoleEdgeThresholdMin, lumaMax * fxaaConsoleEdgeThreshold)) return rgbyM;\n"
//		"/*--------------------------------------------------------------------------*/\n"
//		"    float2 dir;\n"
//		"    dir.x = dot(lumaNwNeSwSe, fxaaConsole360ConstDir.yyxx);\n"
//		"    dir.y = dot(lumaNwNeSwSe, fxaaConsole360ConstDir.xyxy);\n"
//		"    dir = normalize(dir);\n"
//		"/*--------------------------------------------------------------------------*/\n"
//		"    float4 dir1 = dir.xyxy * fxaaConsoleRcpFrameOpt.xyzw;\n"
//		"/*--------------------------------------------------------------------------*/\n"
//		"    float4 dir2;\n"
//		"    float dirAbsMinTimesC = min(abs(dir.x), abs(dir.y)) * fxaaConsoleEdgeSharpness;\n"
//		"    dir2 = saturate(fxaaConsole360ConstDir.zzww * dir.xyxy / dirAbsMinTimesC + 0.5);\n"
//		"    dir2 = dir2 * fxaaConsole360RcpFrameOpt2.xyxy + fxaaConsole360RcpFrameOpt2.zwzw;\n"
//		"/*--------------------------------------------------------------------------*/\n"
//		"    float4 rgbyN1 = tex2Dlod(fxaaConsole360TexExpBiasNegOne, float4(pos.xy + dir1.xy, 0.0, 0.0));\n"
//		"    float4 rgbyP1 = tex2Dlod(fxaaConsole360TexExpBiasNegOne, float4(pos.xy + dir1.zw, 0.0, 0.0));\n"
//		"    float4 rgbyN2 = tex2Dlod(fxaaConsole360TexExpBiasNegTwo, float4(pos.xy + dir2.xy, 0.0, 0.0));\n"
//		"    float4 rgbyP2 = tex2Dlod(fxaaConsole360TexExpBiasNegTwo, float4(pos.xy + dir2.zw, 0.0, 0.0));\n"
//		"/*--------------------------------------------------------------------------*/\n"
//		"    float4 rgbyA = rgbyN1 + rgbyP1;\n"
//		"    float4 rgbyB = rgbyN2 + rgbyP2 + rgbyA * 0.5;\n"
//		"/*--------------------------------------------------------------------------*/\n"
//		"    float4 rgbyR = ((FxaaLuma(rgbyB) - lumaMax) > 0.0) ? rgbyA : rgbyB; \n"
//		"    rgbyR = ((FxaaLuma(rgbyB) - lumaMin) > 0.0) ? rgbyR : rgbyA; \n"
//		"    return rgbyR; }\n"
//		"/*==========================================================================*/\n"
//		"#endif\n"
//		"\n"
//		//"\n"
//		//"\n"
//		//"/*============================================================================\n"
//		//"\n"
//		//"         FXAA3 CONSOLE - OPTIMIZED PS3 PIXEL SHADER (NO EARLY EXIT)\n"
//		//"\n"
//		//"==============================================================================\n"
//		//"The code below does not exactly match the assembly.\n"
//		//"I have a feeling that 12 cycles is possible, but was not able to get there.\n"
//		//"Might have to increase register count to get full performance.\n"
//		//"Note this shader does not use perspective interpolation.\n"
//		//"\n"
//		//"Use the following cgc options,\n"
//		//"\n"
//		//"  --fenable-bx2 --fastmath --fastprecision --nofloatbindings\n"
//		//"\n"
//		//"------------------------------------------------------------------------------\n"
//		//"                             NVSHADERPERF OUTPUT\n"
//		//"------------------------------------------------------------------------------\n"
//		//"For reference and to aid in debug, output of NVShaderPerf should match this,\n"
//		//"\n"
//		//"Shader to schedule:\n"
//		//"  0: texpkb h0.w(TRUE), v5.zyxx, #0\n"
//		//"  2: addh h2.z(TRUE), h0.w, constant(0.001953, 0.000000, 0.000000, 0.000000).x\n"
//		//"  4: texpkb h0.w(TRUE), v5.xwxx, #0\n"
//		//"  6: addh h0.z(TRUE), -h2, h0.w\n"
//		//"  7: texpkb h1.w(TRUE), v5, #0\n"
//		//"  9: addh h0.x(TRUE), h0.z, -h1.w\n"
//		//" 10: addh h3.w(TRUE), h0.z, h1\n"
//		//" 11: texpkb h2.w(TRUE), v5.zwzz, #0\n"
//		//" 13: addh h0.z(TRUE), h3.w, -h2.w\n"
//		//" 14: addh h0.x(TRUE), h2.w, h0\n"
//		//" 15: nrmh h1.xz(TRUE), h0_n\n"
//		//" 16: minh_m8 h0.x(TRUE), |h1|, |h1.z|\n"
//		//" 17: maxh h4.w(TRUE), h0, h1\n"
//		//" 18: divx h2.xy(TRUE), h1_n.xzzw, h0_n\n"
//		//" 19: movr r1.zw(TRUE), v4.xxxy\n"
//		//" 20: madr r2.xz(TRUE), -h1, constant(cConst5.x, cConst5.y, cConst5.z, cConst5.w).zzww, r1.zzww\n"
//		//" 22: minh h5.w(TRUE), h0, h1\n"
//		//" 23: texpkb h0(TRUE), r2.xzxx, #0\n"
//		//" 25: madr r0.zw(TRUE), h1.xzxz, constant(cConst5.x, cConst5.y, cConst5.z, cConst5.w), r1\n"
//		//" 27: maxh h4.x(TRUE), h2.z, h2.w\n"
//		//" 28: texpkb h1(TRUE), r0.zwzz, #0\n"
//		//" 30: addh_d2 h1(TRUE), h0, h1\n"
//		//" 31: madr r0.xy(TRUE), -h2, constant(cConst5.x, cConst5.y, cConst5.z, cConst5.w).xyxx, r1.zwzz\n"
//		//" 33: texpkb h0(TRUE), r0, #0\n"
//		//" 35: minh h4.z(TRUE), h2, h2.w\n"
//		//" 36: fenct TRUE\n"
//		//" 37: madr r1.xy(TRUE), h2, constant(cConst5.x, cConst5.y, cConst5.z, cConst5.w).xyxx, r1.zwzz\n"
//		//" 39: texpkb h2(TRUE), r1, #0\n"
//		//" 41: addh_d2 h0(TRUE), h0, h2\n"
//		//" 42: maxh h2.w(TRUE), h4, h4.x\n"
//		//" 43: minh h2.x(TRUE), h5.w, h4.z\n"
//		//" 44: addh_d2 h0(TRUE), h0, h1\n"
//		//" 45: slth h2.x(TRUE), h0.w, h2\n"
//		//" 46: sgth h2.w(TRUE), h0, h2\n"
//		//" 47: movh h0(TRUE), h0\n"
//		//" 48: addx.c0 rc(TRUE), h2, h2.w\n"
//		//" 49: movh h0(c0.NE.x), h1\n"
//		//"\n"
//		//"IPU0 ------ Simplified schedule: --------\n"
//		//"Pass |  Unit  |  uOp |  PC:  Op\n"
//		//"-----+--------+------+-------------------------\n"
//		//"   1 | SCT0/1 |  mov |   0:  TXLr h0.w, g[TEX1].zyxx, const.xxxx, TEX0;\n"
//		//"     |    TEX |  txl |   0:  TXLr h0.w, g[TEX1].zyxx, const.xxxx, TEX0;\n"
//		//"     |   SCB1 |  add |   2:  ADDh h2.z, h0.--w-, const.--x-;\n"
//		//"     |        |      |\n"
//		//"   2 | SCT0/1 |  mov |   4:  TXLr h0.w, g[TEX1].xwxx, const.xxxx, TEX0;\n"
//		//"     |    TEX |  txl |   4:  TXLr h0.w, g[TEX1].xwxx, const.xxxx, TEX0;\n"
//		//"     |   SCB1 |  add |   6:  ADDh h0.z,-h2, h0.--w-;\n"
//		//"     |        |      |\n"
//		//"   3 | SCT0/1 |  mov |   7:  TXLr h1.w, g[TEX1], const.xxxx, TEX0;\n"
//		//"     |    TEX |  txl |   7:  TXLr h1.w, g[TEX1], const.xxxx, TEX0;\n"
//		//"     |   SCB0 |  add |   9:  ADDh h0.x, h0.z---,-h1.w---;\n"
//		//"     |   SCB1 |  add |  10:  ADDh h3.w, h0.---z, h1;\n"
//		//"     |        |      |\n"
//		//"   4 | SCT0/1 |  mov |  11:  TXLr h2.w, g[TEX1].zwzz, const.xxxx, TEX0;\n"
//		//"     |    TEX |  txl |  11:  TXLr h2.w, g[TEX1].zwzz, const.xxxx, TEX0;\n"
//		//"     |   SCB0 |  add |  14:  ADDh h0.x, h2.w---, h0;\n"
//		//"     |   SCB1 |  add |  13:  ADDh h0.z, h3.--w-,-h2.--w-;\n"
//		//"     |        |      |\n"
//		//"   5 |   SCT1 |  mov |  15:  NRMh h1.xz, h0;\n"
//		//"     |    SRB |  nrm |  15:  NRMh h1.xz, h0;\n"
//		//"     |   SCB0 |  min |  16:  MINh*8 h0.x, |h1|, |h1.z---|;\n"
//		//"     |   SCB1 |  max |  17:  MAXh h4.w, h0, h1;\n"
//		//"     |        |      |\n"
//		//"   6 |   SCT0 |  div |  18:  DIVx h2.xy, h1.xz--, h0;\n"
//		//"     |   SCT1 |  mov |  19:  MOVr r1.zw, g[TEX0].--xy;\n"
//		//"     |   SCB0 |  mad |  20:  MADr r2.xz,-h1, const.z-w-, r1.z-w-;\n"
//		//"     |   SCB1 |  min |  22:  MINh h5.w, h0, h1;\n"
//		//"     |        |      |\n"
//		//"   7 | SCT0/1 |  mov |  23:  TXLr h0, r2.xzxx, const.xxxx, TEX0;\n"
//		//"     |    TEX |  txl |  23:  TXLr h0, r2.xzxx, const.xxxx, TEX0;\n"
//		//"     |   SCB0 |  max |  27:  MAXh h4.x, h2.z---, h2.w---;\n"
//		//"     |   SCB1 |  mad |  25:  MADr r0.zw, h1.--xz, const, r1;\n"
//		//"     |        |      |\n"
//		//"   8 | SCT0/1 |  mov |  28:  TXLr h1, r0.zwzz, const.xxxx, TEX0;\n"
//		//"     |    TEX |  txl |  28:  TXLr h1, r0.zwzz, const.xxxx, TEX0;\n"
//		//"     | SCB0/1 |  add |  30:  ADDh/2 h1, h0, h1;\n"
//		//"     |        |      |\n"
//		//"   9 |   SCT0 |  mad |  31:  MADr r0.xy,-h2, const.xy--, r1.zw--;\n"
//		//"     |   SCT1 |  mov |  33:  TXLr h0, r0, const.zzzz, TEX0;\n"
//		//"     |    TEX |  txl |  33:  TXLr h0, r0, const.zzzz, TEX0;\n"
//		//"     |   SCB1 |  min |  35:  MINh h4.z, h2, h2.--w-;\n"
//		//"     |        |      |\n"
//		//"  10 |   SCT0 |  mad |  37:  MADr r1.xy, h2, const.xy--, r1.zw--;\n"
//		//"     |   SCT1 |  mov |  39:  TXLr h2, r1, const.zzzz, TEX0;\n"
//		//"     |    TEX |  txl |  39:  TXLr h2, r1, const.zzzz, TEX0;\n"
//		//"     | SCB0/1 |  add |  41:  ADDh/2 h0, h0, h2;\n"
//		//"     |        |      |\n"
//		//"  11 |   SCT0 |  min |  43:  MINh h2.x, h5.w---, h4.z---;\n"
//		//"     |   SCT1 |  max |  42:  MAXh h2.w, h4, h4.---x;\n"
//		//"     | SCB0/1 |  add |  44:  ADDh/2 h0, h0, h1;\n"
//		//"     |        |      |\n"
//		//"  12 |   SCT0 |  set |  45:  SLTh h2.x, h0.w---, h2;\n"
//		//"     |   SCT1 |  set |  46:  SGTh h2.w, h0, h2;\n"
//		//"     | SCB0/1 |  mul |  47:  MOVh h0, h0;\n"
//		//"     |        |      |\n"
//		//"  13 |   SCT0 |  mad |  48:  ADDxc0_s rc, h2, h2.w---;\n"
//		//"     | SCB0/1 |  mul |  49:  MOVh h0(NE0.xxxx), h1;\n"
//		//" \n"
//		//"Pass   SCT  TEX  SCB\n"
//		//"  1:   0% 100%  25%\n"
//		//"  2:   0% 100%  25%\n"
//		//"  3:   0% 100%  50%\n"
//		//"  4:   0% 100%  50%\n"
//		//"  5:   0%   0%  50%\n"
//		//"  6: 100%   0%  75%\n"
//		//"  7:   0% 100%  75%\n"
//		//"  8:   0% 100% 100%\n"
//		//"  9:   0% 100%  25%\n"
//		//" 10:   0% 100% 100%\n"
//		//" 11:  50%   0% 100%\n"
//		//" 12:  50%   0% 100%\n"
//		//" 13:  25%   0% 100%\n"
//		//"\n"
//		//"MEAN:  17%  61%  67%\n"
//		//"\n"
//		//"Pass   SCT0  SCT1   TEX  SCB0  SCB1\n"
//		//"  1:    0%    0%  100%    0%  100%\n"
//		//"  2:    0%    0%  100%    0%  100%\n"
//		//"  3:    0%    0%  100%  100%  100%\n"
//		//"  4:    0%    0%  100%  100%  100%\n"
//		//"  5:    0%    0%    0%  100%  100%\n"
//		//"  6:  100%  100%    0%  100%  100%\n"
//		//"  7:    0%    0%  100%  100%  100%\n"
//		//"  8:    0%    0%  100%  100%  100%\n"
//		//"  9:    0%    0%  100%    0%  100%\n"
//		//" 10:    0%    0%  100%  100%  100%\n"
//		//" 11:  100%  100%    0%  100%  100%\n"
//		//" 12:  100%  100%    0%  100%  100%\n"
//		//" 13:  100%    0%    0%  100%  100%\n"
//		//"\n"
//		//"MEAN:   30%   23%   61%   76%  100%\n"
//		//"Fragment Performance Setup: Driver RSX Compiler, GPU RSX, Flags 0x5\n"
//		//"Results 13 cycles, 3 r regs, 923,076,923 pixels/s\n"
//		//"============================================================================*/\n"
//		//"#if (FXAA_PS3 == 1) && (FXAA_EARLY_EXIT == 0)\n"
//		//"/*--------------------------------------------------------------------------*/\n"
//		//"#pragma regcount 7\n"
//		//"#pragma disablepc all\n"
//		//"#pragma option O3\n"
//		//"#pragma option OutColorPrec=fp16\n"
//		//"#pragma texformat default RGBA8\n"
//		//"/*==========================================================================*/\n"
//		//"half4 FxaaPixelShader(\n"
//		//"    // See FXAA Quality FxaaPixelShader() source for docs on Inputs!\n"
//		//"    FxaaFloat2 pos,\n"
//		//"    FxaaFloat4 fxaaConsolePosPos,\n"
//		//"    FxaaTex tex,\n"
//		//"    FxaaTex fxaaConsole360TexExpBiasNegOne,\n"
//		//"    FxaaTex fxaaConsole360TexExpBiasNegTwo,\n"
//		//"    FxaaFloat2 fxaaQualityRcpFrame,\n"
//		//"    FxaaFloat4 fxaaConsoleRcpFrameOpt,\n"
//		//"    FxaaFloat4 fxaaConsoleRcpFrameOpt2,\n"
//		//"    FxaaFloat4 fxaaConsole360RcpFrameOpt2,\n"
//		//"    FxaaFloat fxaaQualitySubpix,\n"
//		//"    FxaaFloat fxaaQualityEdgeThreshold,\n"
//		//"    FxaaFloat fxaaQualityEdgeThresholdMin,\n"
//		//"    FxaaFloat fxaaConsoleEdgeSharpness,\n"
//		//"    FxaaFloat fxaaConsoleEdgeThreshold,\n"
//		//"    FxaaFloat fxaaConsoleEdgeThresholdMin,\n"
//		//"    FxaaFloat4 fxaaConsole360ConstDir\n"
//		//") {\n"
//		//"/*--------------------------------------------------------------------------*/\n"
//		//"// (1)\n"
//		//"    half4 dir;\n"
//		//"    half4 lumaNe = h4tex2Dlod(tex, half4(fxaaConsolePosPos.zy, 0, 0));\n"
//		//"    #if (FXAA_GREEN_AS_LUMA == 0)\n"
//		//"        lumaNe.w += half(1.0/512.0);\n"
//		//"        dir.x = -lumaNe.w;\n"
//		//"        dir.z = -lumaNe.w;\n"
//		//"    #else\n"
//		//"        lumaNe.y += half(1.0/512.0);\n"
//		//"        dir.x = -lumaNe.y;\n"
//		//"        dir.z = -lumaNe.y;\n"
//		//"    #endif\n"
//		//"/*--------------------------------------------------------------------------*/\n"
//		//"// (2)\n"
//		//"    half4 lumaSw = h4tex2Dlod(tex, half4(fxaaConsolePosPos.xw, 0, 0));\n"
//		//"    #if (FXAA_GREEN_AS_LUMA == 0)\n"
//		//"        dir.x += lumaSw.w;\n"
//		//"        dir.z += lumaSw.w;\n"
//		//"    #else\n"
//		//"        dir.x += lumaSw.y;\n"
//		//"        dir.z += lumaSw.y;\n"
//		//"    #endif        \n"
//		//"/*--------------------------------------------------------------------------*/\n"
//		//"// (3)\n"
//		//"    half4 lumaNw = h4tex2Dlod(tex, half4(fxaaConsolePosPos.xy, 0, 0));\n"
//		//"    #if (FXAA_GREEN_AS_LUMA == 0)\n"
//		//"        dir.x -= lumaNw.w;\n"
//		//"        dir.z += lumaNw.w;\n"
//		//"    #else\n"
//		//"        dir.x -= lumaNw.y;\n"
//		//"        dir.z += lumaNw.y;\n"
//		//"    #endif\n"
//		//"/*--------------------------------------------------------------------------*/\n"
//		//"// (4)\n"
//		//"    half4 lumaSe = h4tex2Dlod(tex, half4(fxaaConsolePosPos.zw, 0, 0));\n"
//		//"    #if (FXAA_GREEN_AS_LUMA == 0)\n"
//		//"        dir.x += lumaSe.w;\n"
//		//"        dir.z -= lumaSe.w;\n"
//		//"    #else\n"
//		//"        dir.x += lumaSe.y;\n"
//		//"        dir.z -= lumaSe.y;\n"
//		//"    #endif\n"
//		//"/*--------------------------------------------------------------------------*/\n"
//		//"// (5)\n"
//		//"    half4 dir1_pos;\n"
//		//"    dir1_pos.xy = normalize(dir.xyz).xz;\n"
//		//"    half dirAbsMinTimesC = min(abs(dir1_pos.x), abs(dir1_pos.y)) * half(FXAA_CONSOLE__PS3_EDGE_SHARPNESS);\n"
//		//"/*--------------------------------------------------------------------------*/\n"
//		//"// (6)\n"
//		//"    half4 dir2_pos;\n"
//		//"    dir2_pos.xy = clamp(dir1_pos.xy / dirAbsMinTimesC, half(-2.0), half(2.0));\n"
//		//"    dir1_pos.zw = pos.xy;\n"
//		//"    dir2_pos.zw = pos.xy;\n"
//		//"    half4 temp1N;\n"
//		//"    temp1N.xy = dir1_pos.zw - dir1_pos.xy * fxaaConsoleRcpFrameOpt.zw;\n"
//		//"/*--------------------------------------------------------------------------*/\n"
//		//"// (7)\n"
//		//"    temp1N = h4tex2Dlod(tex, half4(temp1N.xy, 0.0, 0.0));\n"
//		//"    half4 rgby1;\n"
//		//"    rgby1.xy = dir1_pos.zw + dir1_pos.xy * fxaaConsoleRcpFrameOpt.zw;\n"
//		//"/*--------------------------------------------------------------------------*/\n"
//		//"// (8)\n"
//		//"    rgby1 = h4tex2Dlod(tex, half4(rgby1.xy, 0.0, 0.0));\n"
//		//"    rgby1 = (temp1N + rgby1) * 0.5;\n"
//		//"/*--------------------------------------------------------------------------*/\n"
//		//"// (9)\n"
//		//"    half4 temp2N;\n"
//		//"    temp2N.xy = dir2_pos.zw - dir2_pos.xy * fxaaConsoleRcpFrameOpt2.zw;\n"
//		//"    temp2N = h4tex2Dlod(tex, half4(temp2N.xy, 0.0, 0.0));\n"
//		//"/*--------------------------------------------------------------------------*/\n"
//		//"// (10)\n"
//		//"    half4 rgby2;\n"
//		//"    rgby2.xy = dir2_pos.zw + dir2_pos.xy * fxaaConsoleRcpFrameOpt2.zw;\n"
//		//"    rgby2 = h4tex2Dlod(tex, half4(rgby2.xy, 0.0, 0.0));\n"
//		//"    rgby2 = (temp2N + rgby2) * 0.5;\n"
//		//"/*--------------------------------------------------------------------------*/\n"
//		//"// (11)\n"
//		//"    // compilier moves these scalar ops up to other cycles\n"
//		//"    #if (FXAA_GREEN_AS_LUMA == 0)\n"
//		//"        half lumaMin = min(min(lumaNw.w, lumaSw.w), min(lumaNe.w, lumaSe.w));\n"
//		//"        half lumaMax = max(max(lumaNw.w, lumaSw.w), max(lumaNe.w, lumaSe.w));\n"
//		//"    #else\n"
//		//"        half lumaMin = min(min(lumaNw.y, lumaSw.y), min(lumaNe.y, lumaSe.y));\n"
//		//"        half lumaMax = max(max(lumaNw.y, lumaSw.y), max(lumaNe.y, lumaSe.y));\n"
//		//"    #endif        \n"
//		//"    rgby2 = (rgby2 + rgby1) * 0.5;\n"
//		//"/*--------------------------------------------------------------------------*/\n"
//		//"// (12)\n"
//		//"    #if (FXAA_GREEN_AS_LUMA == 0)\n"
//		//"        bool twoTapLt = rgby2.w < lumaMin;\n"
//		//"        bool twoTapGt = rgby2.w > lumaMax;\n"
//		//"    #else\n"
//		//"        bool twoTapLt = rgby2.y < lumaMin;\n"
//		//"        bool twoTapGt = rgby2.y > lumaMax;\n"
//		//"    #endif\n"
//		//"/*--------------------------------------------------------------------------*/\n"
//		//"// (13)\n"
//		//"    if(twoTapLt || twoTapGt) rgby2 = rgby1;\n"
//		//"/*--------------------------------------------------------------------------*/\n"
//		//"    return rgby2; }\n"
//		//"/*==========================================================================*/\n"
//		//"#endif\n"
//		//"\n"
//		//"\n"
//		//"\n"
//		//"/*============================================================================\n"
//		//"\n"
//		//"       FXAA3 CONSOLE - OPTIMIZED PS3 PIXEL SHADER (WITH EARLY EXIT)\n"
//		//"\n"
//		//"==============================================================================\n"
//		//"The code mostly matches the assembly.\n"
//		//"I have a feeling that 14 cycles is possible, but was not able to get there.\n"
//		//"Might have to increase register count to get full performance.\n"
//		//"Note this shader does not use perspective interpolation.\n"
//		//"\n"
//		//"Use the following cgc options,\n"
//		//"\n"
//		//" --fenable-bx2 --fastmath --fastprecision --nofloatbindings\n"
//		//"\n"
//		//"Use of FXAA_GREEN_AS_LUMA currently adds a cycle (16 clks).\n"
//		//"Will look at fixing this for FXAA 3.12.\n"
//		//"------------------------------------------------------------------------------\n"
//		//"                             NVSHADERPERF OUTPUT\n"
//		//"------------------------------------------------------------------------------\n"
//		//"For reference and to aid in debug, output of NVShaderPerf should match this,\n"
//		//"\n"
//		//"Shader to schedule:\n"
//		//"  0: texpkb h0.w(TRUE), v5.zyxx, #0\n"
//		//"  2: addh h2.y(TRUE), h0.w, constant(0.001953, 0.000000, 0.000000, 0.000000).x\n"
//		//"  4: texpkb h1.w(TRUE), v5.xwxx, #0\n"
//		//"  6: addh h0.x(TRUE), h1.w, -h2.y\n"
//		//"  7: texpkb h2.w(TRUE), v5.zwzz, #0\n"
//		//"  9: minh h4.w(TRUE), h2.y, h2\n"
//		//" 10: maxh h5.x(TRUE), h2.y, h2.w\n"
//		//" 11: texpkb h0.w(TRUE), v5, #0\n"
//		//" 13: addh h3.w(TRUE), -h0, h0.x\n"
//		//" 14: addh h0.x(TRUE), h0.w, h0\n"
//		//" 15: addh h0.z(TRUE), -h2.w, h0.x\n"
//		//" 16: addh h0.x(TRUE), h2.w, h3.w\n"
//		//" 17: minh h5.y(TRUE), h0.w, h1.w\n"
//		//" 18: nrmh h2.xz(TRUE), h0_n\n"
//		//" 19: minh_m8 h2.w(TRUE), |h2.x|, |h2.z|\n"
//		//" 20: divx h4.xy(TRUE), h2_n.xzzw, h2_n.w\n"
//		//" 21: movr r1.zw(TRUE), v4.xxxy\n"
//		//" 22: maxh h2.w(TRUE), h0, h1\n"
//		//" 23: fenct TRUE\n"
//		//" 24: madr r0.xy(TRUE), -h2.xzzw, constant(cConst5.x, cConst5.y, cConst5.z, cConst5.w).zwzz, r1.zwzz\n"
//		//" 26: texpkb h0(TRUE), r0, #0\n"
//		//" 28: maxh h5.x(TRUE), h2.w, h5\n"
//		//" 29: minh h5.w(TRUE), h5.y, h4\n"
//		//" 30: madr r1.xy(TRUE), h2.xzzw, constant(cConst5.x, cConst5.y, cConst5.z, cConst5.w).zwzz, r1.zwzz\n"
//		//" 32: texpkb h2(TRUE), r1, #0\n"
//		//" 34: addh_d2 h2(TRUE), h0, h2\n"
//		//" 35: texpkb h1(TRUE), v4, #0\n"
//		//" 37: maxh h5.y(TRUE), h5.x, h1.w\n"
//		//" 38: minh h4.w(TRUE), h1, h5\n"
//		//" 39: madr r0.xy(TRUE), -h4, constant(cConst5.x, cConst5.y, cConst5.z, cConst5.w).xyxx, r1.zwzz\n"
//		//" 41: texpkb h0(TRUE), r0, #0\n"
//		//" 43: addh_m8 h5.z(TRUE), h5.y, -h4.w\n"
//		//" 44: madr r2.xy(TRUE), h4, constant(cConst5.x, cConst5.y, cConst5.z, cConst5.w).xyxx, r1.zwzz\n"
//		//" 46: texpkb h3(TRUE), r2, #0\n"
//		//" 48: addh_d2 h0(TRUE), h0, h3\n"
//		//" 49: addh_d2 h3(TRUE), h0, h2\n"
//		//" 50: movh h0(TRUE), h3\n"
//		//" 51: slth h3.x(TRUE), h3.w, h5.w\n"
//		//" 52: sgth h3.w(TRUE), h3, h5.x\n"
//		//" 53: addx.c0 rc(TRUE), h3.x, h3\n"
//		//" 54: slth.c0 rc(TRUE), h5.z, h5\n"
//		//" 55: movh h0(c0.NE.w), h2\n"
//		//" 56: movh h0(c0.NE.x), h1\n"
//		//"\n"
//		//"IPU0 ------ Simplified schedule: --------\n"
//		//"Pass |  Unit  |  uOp |  PC:  Op\n"
//		//"-----+--------+------+-------------------------\n"
//		//"   1 | SCT0/1 |  mov |   0:  TXLr h0.w, g[TEX1].zyxx, const.xxxx, TEX0;\n"
//		//"     |    TEX |  txl |   0:  TXLr h0.w, g[TEX1].zyxx, const.xxxx, TEX0;\n"
//		//"     |   SCB0 |  add |   2:  ADDh h2.y, h0.-w--, const.-x--;\n"
//		//"     |        |      |\n"
//		//"   2 | SCT0/1 |  mov |   4:  TXLr h1.w, g[TEX1].xwxx, const.xxxx, TEX0;\n"
//		//"     |    TEX |  txl |   4:  TXLr h1.w, g[TEX1].xwxx, const.xxxx, TEX0;\n"
//		//"     |   SCB0 |  add |   6:  ADDh h0.x, h1.w---,-h2.y---;\n"
//		//"     |        |      |\n"
//		//"   3 | SCT0/1 |  mov |   7:  TXLr h2.w, g[TEX1].zwzz, const.xxxx, TEX0;\n"
//		//"     |    TEX |  txl |   7:  TXLr h2.w, g[TEX1].zwzz, const.xxxx, TEX0;\n"
//		//"     |   SCB0 |  max |  10:  MAXh h5.x, h2.y---, h2.w---;\n"
//		//"     |   SCB1 |  min |   9:  MINh h4.w, h2.---y, h2;\n"
//		//"     |        |      |\n"
//		//"   4 | SCT0/1 |  mov |  11:  TXLr h0.w, g[TEX1], const.xxxx, TEX0;\n"
//		//"     |    TEX |  txl |  11:  TXLr h0.w, g[TEX1], const.xxxx, TEX0;\n"
//		//"     |   SCB0 |  add |  14:  ADDh h0.x, h0.w---, h0;\n"
//		//"     |   SCB1 |  add |  13:  ADDh h3.w,-h0, h0.---x;\n"
//		//"     |        |      |\n"
//		//"   5 |   SCT0 |  mad |  16:  ADDh h0.x, h2.w---, h3.w---;\n"
//		//"     |   SCT1 |  mad |  15:  ADDh h0.z,-h2.--w-, h0.--x-;\n"
//		//"     |   SCB0 |  min |  17:  MINh h5.y, h0.-w--, h1.-w--;\n"
//		//"     |        |      |\n"
//		//"   6 |   SCT1 |  mov |  18:  NRMh h2.xz, h0;\n"
//		//"     |    SRB |  nrm |  18:  NRMh h2.xz, h0;\n"
//		//"     |   SCB1 |  min |  19:  MINh*8 h2.w, |h2.---x|, |h2.---z|;\n"
//		//"     |        |      |\n"
//		//"   7 |   SCT0 |  div |  20:  DIVx h4.xy, h2.xz--, h2.ww--;\n"
//		//"     |   SCT1 |  mov |  21:  MOVr r1.zw, g[TEX0].--xy;\n"
//		//"     |   SCB1 |  max |  22:  MAXh h2.w, h0, h1;\n"
//		//"     |        |      |\n"
//		//"   8 |   SCT0 |  mad |  24:  MADr r0.xy,-h2.xz--, const.zw--, r1.zw--;\n"
//		//"     |   SCT1 |  mov |  26:  TXLr h0, r0, const.xxxx, TEX0;\n"
//		//"     |    TEX |  txl |  26:  TXLr h0, r0, const.xxxx, TEX0;\n"
//		//"     |   SCB0 |  max |  28:  MAXh h5.x, h2.w---, h5;\n"
//		//"     |   SCB1 |  min |  29:  MINh h5.w, h5.---y, h4;\n"
//		//"     |        |      |\n"
//		//"   9 |   SCT0 |  mad |  30:  MADr r1.xy, h2.xz--, const.zw--, r1.zw--;\n"
//		//"     |   SCT1 |  mov |  32:  TXLr h2, r1, const.xxxx, TEX0;\n"
//		//"     |    TEX |  txl |  32:  TXLr h2, r1, const.xxxx, TEX0;\n"
//		//"     | SCB0/1 |  add |  34:  ADDh/2 h2, h0, h2;\n"
//		//"     |        |      |\n"
//		//"  10 | SCT0/1 |  mov |  35:  TXLr h1, g[TEX0], const.xxxx, TEX0;\n"
//		//"     |    TEX |  txl |  35:  TXLr h1, g[TEX0], const.xxxx, TEX0;\n"
//		//"     |   SCB0 |  max |  37:  MAXh h5.y, h5.-x--, h1.-w--;\n"
//		//"     |   SCB1 |  min |  38:  MINh h4.w, h1, h5;\n"
//		//"     |        |      |\n"
//		//"  11 |   SCT0 |  mad |  39:  MADr r0.xy,-h4, const.xy--, r1.zw--;\n"
//		//"     |   SCT1 |  mov |  41:  TXLr h0, r0, const.zzzz, TEX0;\n"
//		//"     |    TEX |  txl |  41:  TXLr h0, r0, const.zzzz, TEX0;\n"
//		//"     |   SCB0 |  mad |  44:  MADr r2.xy, h4, const.xy--, r1.zw--;\n"
//		//"     |   SCB1 |  add |  43:  ADDh*8 h5.z, h5.--y-,-h4.--w-;\n"
//		//"     |        |      |\n"
//		//"  12 | SCT0/1 |  mov |  46:  TXLr h3, r2, const.xxxx, TEX0;\n"
//		//"     |    TEX |  txl |  46:  TXLr h3, r2, const.xxxx, TEX0;\n"
//		//"     | SCB0/1 |  add |  48:  ADDh/2 h0, h0, h3;\n"
//		//"     |        |      |\n"
//		//"  13 | SCT0/1 |  mad |  49:  ADDh/2 h3, h0, h2;\n"
//		//"     | SCB0/1 |  mul |  50:  MOVh h0, h3;\n"
//		//"     |        |      |\n"
//		//"  14 |   SCT0 |  set |  51:  SLTh h3.x, h3.w---, h5.w---;\n"
//		//"     |   SCT1 |  set |  52:  SGTh h3.w, h3, h5.---x;\n"
//		//"     |   SCB0 |  set |  54:  SLThc0 rc, h5.z---, h5;\n"
//		//"     |   SCB1 |  add |  53:  ADDxc0_s rc, h3.---x, h3;\n"
//		//"     |        |      |\n"
//		//"  15 | SCT0/1 |  mul |  55:  MOVh h0(NE0.wwww), h2;\n"
//		//"     | SCB0/1 |  mul |  56:  MOVh h0(NE0.xxxx), h1;\n"
//		//" \n"
//		//"Pass   SCT  TEX  SCB\n"
//		//"  1:   0% 100%  25%\n"
//		//"  2:   0% 100%  25%\n"
//		//"  3:   0% 100%  50%\n"
//		//"  4:   0% 100%  50%\n"
//		//"  5:  50%   0%  25%\n"
//		//"  6:   0%   0%  25%\n"
//		//"  7: 100%   0%  25%\n"
//		//"  8:   0% 100%  50%\n"
//		//"  9:   0% 100% 100%\n"
//		//" 10:   0% 100%  50%\n"
//		//" 11:   0% 100%  75%\n"
//		//" 12:   0% 100% 100%\n"
//		//" 13: 100%   0% 100%\n"
//		//" 14:  50%   0%  50%\n"
//		//" 15: 100%   0% 100%\n"
//		//"\n"
//		//"MEAN:  26%  60%  56%\n"
//		//"\n"
//		//"Pass   SCT0  SCT1   TEX  SCB0  SCB1\n"
//		//"  1:    0%    0%  100%  100%    0%\n"
//		//"  2:    0%    0%  100%  100%    0%\n"
//		//"  3:    0%    0%  100%  100%  100%\n"
//		//"  4:    0%    0%  100%  100%  100%\n"
//		//"  5:  100%  100%    0%  100%    0%\n"
//		//"  6:    0%    0%    0%    0%  100%\n"
//		//"  7:  100%  100%    0%    0%  100%\n"
//		//"  8:    0%    0%  100%  100%  100%\n"
//		//"  9:    0%    0%  100%  100%  100%\n"
//		//" 10:    0%    0%  100%  100%  100%\n"
//		//" 11:    0%    0%  100%  100%  100%\n"
//		//" 12:    0%    0%  100%  100%  100%\n"
//		//" 13:  100%  100%    0%  100%  100%\n"
//		//" 14:  100%  100%    0%  100%  100%\n"
//		//" 15:  100%  100%    0%  100%  100%\n"
//		//"\n"
//		//"MEAN:   33%   33%   60%   86%   80%\n"
//		//"Fragment Performance Setup: Driver RSX Compiler, GPU RSX, Flags 0x5\n"
//		//"Results 15 cycles, 3 r regs, 800,000,000 pixels/s\n"
//		//"============================================================================*/\n"
//		//"#if (FXAA_PS3 == 1) && (FXAA_EARLY_EXIT == 1)\n"
//		//"/*--------------------------------------------------------------------------*/\n"
//		//"#pragma regcount 7\n"
//		//"#pragma disablepc all\n"
//		//"#pragma option O2\n"
//		//"#pragma option OutColorPrec=fp16\n"
//		//"#pragma texformat default RGBA8\n"
//		//"/*==========================================================================*/\n"
//		//"half4 FxaaPixelShader(\n"
//		//"    // See FXAA Quality FxaaPixelShader() source for docs on Inputs!\n"
//		//"    FxaaFloat2 pos,\n"
//		//"    FxaaFloat4 fxaaConsolePosPos,\n"
//		//"    FxaaTex tex,\n"
//		//"    FxaaTex fxaaConsole360TexExpBiasNegOne,\n"
//		//"    FxaaTex fxaaConsole360TexExpBiasNegTwo,\n"
//		//"    FxaaFloat2 fxaaQualityRcpFrame,\n"
//		//"    FxaaFloat4 fxaaConsoleRcpFrameOpt,\n"
//		//"    FxaaFloat4 fxaaConsoleRcpFrameOpt2,\n"
//		//"    FxaaFloat4 fxaaConsole360RcpFrameOpt2,\n"
//		//"    FxaaFloat fxaaQualitySubpix,\n"
//		//"    FxaaFloat fxaaQualityEdgeThreshold,\n"
//		//"    FxaaFloat fxaaQualityEdgeThresholdMin,\n"
//		//"    FxaaFloat fxaaConsoleEdgeSharpness,\n"
//		//"    FxaaFloat fxaaConsoleEdgeThreshold,\n"
//		//"    FxaaFloat fxaaConsoleEdgeThresholdMin,\n"
//		//"    FxaaFloat4 fxaaConsole360ConstDir\n"
//		//") {\n"
//		//"/*--------------------------------------------------------------------------*/\n"
//		//"// (1)\n"
//		//"    half4 rgbyNe = h4tex2Dlod(tex, half4(fxaaConsolePosPos.zy, 0, 0));\n"
//		//"    #if (FXAA_GREEN_AS_LUMA == 0)\n"
//		//"        half lumaNe = rgbyNe.w + half(1.0/512.0);\n"
//		//"    #else\n"
//		//"        half lumaNe = rgbyNe.y + half(1.0/512.0);\n"
//		//"    #endif\n"
//		//"/*--------------------------------------------------------------------------*/\n"
//		//"// (2)\n"
//		//"    half4 lumaSw = h4tex2Dlod(tex, half4(fxaaConsolePosPos.xw, 0, 0));\n"
//		//"    #if (FXAA_GREEN_AS_LUMA == 0)\n"
//		//"        half lumaSwNegNe = lumaSw.w - lumaNe;\n"
//		//"    #else\n"
//		//"        half lumaSwNegNe = lumaSw.y - lumaNe;\n"
//		//"    #endif\n"
//		//"/*--------------------------------------------------------------------------*/\n"
//		//"// (3)\n"
//		//"    half4 lumaNw = h4tex2Dlod(tex, half4(fxaaConsolePosPos.xy, 0, 0));\n"
//		//"    #if (FXAA_GREEN_AS_LUMA == 0)\n"
//		//"        half lumaMaxNwSw = max(lumaNw.w, lumaSw.w);\n"
//		//"        half lumaMinNwSw = min(lumaNw.w, lumaSw.w);\n"
//		//"    #else\n"
//		//"        half lumaMaxNwSw = max(lumaNw.y, lumaSw.y);\n"
//		//"        half lumaMinNwSw = min(lumaNw.y, lumaSw.y);\n"
//		//"    #endif\n"
//		//"/*--------------------------------------------------------------------------*/\n"
//		//"// (4)\n"
//		//"    half4 lumaSe = h4tex2Dlod(tex, half4(fxaaConsolePosPos.zw, 0, 0));\n"
//		//"    #if (FXAA_GREEN_AS_LUMA == 0)\n"
//		//"        half dirZ =  lumaNw.w + lumaSwNegNe;\n"
//		//"        half dirX = -lumaNw.w + lumaSwNegNe;\n"
//		//"    #else\n"
//		//"        half dirZ =  lumaNw.y + lumaSwNegNe;\n"
//		//"        half dirX = -lumaNw.y + lumaSwNegNe;\n"
//		//"    #endif\n"
//		//"/*--------------------------------------------------------------------------*/\n"
//		//"// (5)\n"
//		//"    half3 dir;\n"
//		//"    dir.y = 0.0;\n"
//		//"    #if (FXAA_GREEN_AS_LUMA == 0)\n"
//		//"        dir.x =  lumaSe.w + dirX;\n"
//		//"        dir.z = -lumaSe.w + dirZ;\n"
//		//"        half lumaMinNeSe = min(lumaNe, lumaSe.w);\n"
//		//"    #else\n"
//		//"        dir.x =  lumaSe.y + dirX;\n"
//		//"        dir.z = -lumaSe.y + dirZ;\n"
//		//"        half lumaMinNeSe = min(lumaNe, lumaSe.y);\n"
//		//"    #endif\n"
//		//"/*--------------------------------------------------------------------------*/\n"
//		//"// (6)\n"
//		//"    half4 dir1_pos;\n"
//		//"    dir1_pos.xy = normalize(dir).xz;\n"
//		//"    half dirAbsMinTimes8 = min(abs(dir1_pos.x), abs(dir1_pos.y)) * half(FXAA_CONSOLE__PS3_EDGE_SHARPNESS);\n"
//		//"/*--------------------------------------------------------------------------*/\n"
//		//"// (7)\n"
//		//"    half4 dir2_pos;\n"
//		//"    dir2_pos.xy = clamp(dir1_pos.xy / dirAbsMinTimes8, half(-2.0), half(2.0));\n"
//		//"    dir1_pos.zw = pos.xy;\n"
//		//"    dir2_pos.zw = pos.xy;\n"
//		//"    #if (FXAA_GREEN_AS_LUMA == 0)\n"
//		//"        half lumaMaxNeSe = max(lumaNe, lumaSe.w);\n"
//		//"    #else\n"
//		//"        half lumaMaxNeSe = max(lumaNe, lumaSe.y);\n"
//		//"    #endif\n"
//		//"/*--------------------------------------------------------------------------*/\n"
//		//"// (8)\n"
//		//"    half4 temp1N;\n"
//		//"    temp1N.xy = dir1_pos.zw - dir1_pos.xy * fxaaConsoleRcpFrameOpt.zw;\n"
//		//"    temp1N = h4tex2Dlod(tex, half4(temp1N.xy, 0.0, 0.0));\n"
//		//"    half lumaMax = max(lumaMaxNwSw, lumaMaxNeSe);\n"
//		//"    half lumaMin = min(lumaMinNwSw, lumaMinNeSe);\n"
//		//"/*--------------------------------------------------------------------------*/\n"
//		//"// (9)\n"
//		//"    half4 rgby1;\n"
//		//"    rgby1.xy = dir1_pos.zw + dir1_pos.xy * fxaaConsoleRcpFrameOpt.zw;\n"
//		//"    rgby1 = h4tex2Dlod(tex, half4(rgby1.xy, 0.0, 0.0));\n"
//		//"    rgby1 = (temp1N + rgby1) * 0.5;\n"
//		//"/*--------------------------------------------------------------------------*/\n"
//		//"// (10)\n"
//		//"    half4 rgbyM = h4tex2Dlod(tex, half4(pos.xy, 0.0, 0.0));\n"
//		//"    #if (FXAA_GREEN_AS_LUMA == 0)\n"
//		//"        half lumaMaxM = max(lumaMax, rgbyM.w);\n"
//		//"        half lumaMinM = min(lumaMin, rgbyM.w);\n"
//		//"    #else\n"
//		//"        half lumaMaxM = max(lumaMax, rgbyM.y);\n"
//		//"        half lumaMinM = min(lumaMin, rgbyM.y);\n"
//		//"    #endif\n"
//		//"/*--------------------------------------------------------------------------*/\n"
//		//"// (11)\n"
//		//"    half4 temp2N;\n"
//		//"    temp2N.xy = dir2_pos.zw - dir2_pos.xy * fxaaConsoleRcpFrameOpt2.zw;\n"
//		//"    temp2N = h4tex2Dlod(tex, half4(temp2N.xy, 0.0, 0.0));\n"
//		//"    half4 rgby2;\n"
//		//"    rgby2.xy = dir2_pos.zw + dir2_pos.xy * fxaaConsoleRcpFrameOpt2.zw;\n"
//		//"    half lumaRangeM = (lumaMaxM - lumaMinM) / FXAA_CONSOLE__PS3_EDGE_THRESHOLD;\n"
//		//"/*--------------------------------------------------------------------------*/\n"
//		//"// (12)\n"
//		//"    rgby2 = h4tex2Dlod(tex, half4(rgby2.xy, 0.0, 0.0));\n"
//		//"    rgby2 = (temp2N + rgby2) * 0.5;\n"
//		//"/*--------------------------------------------------------------------------*/\n"
//		//"// (13)\n"
//		//"    rgby2 = (rgby2 + rgby1) * 0.5;\n"
//		//"/*--------------------------------------------------------------------------*/\n"
//		//"// (14)\n"
//		//"    #if (FXAA_GREEN_AS_LUMA == 0)\n"
//		//"        bool twoTapLt = rgby2.w < lumaMin;\n"
//		//"        bool twoTapGt = rgby2.w > lumaMax;\n"
//		//"    #else\n"
//		//"        bool twoTapLt = rgby2.y < lumaMin;\n"
//		//"        bool twoTapGt = rgby2.y > lumaMax;\n"
//		//"    #endif\n"
//		//"    bool earlyExit = lumaRangeM < lumaMax;\n"
//		//"    bool twoTap = twoTapLt || twoTapGt;\n"
//		//"/*--------------------------------------------------------------------------*/\n"
//		//"// (15)\n"
//		//"    if(twoTap) rgby2 = rgby1;\n"
//		//"    if(earlyExit) rgby2 = rgbyM;\n"
//		//"/*--------------------------------------------------------------------------*/\n"
//		//"    return rgby2; }\n"
//		//"/*==========================================================================*/\n"
//		//"#endif\n"
//		"\n"
//		"\n"
//		"\n"
//		"\n"
//		"vec4 apply( sampler2D tex, vec2 pos )"
//		"{\n"
//		"	vec2 texSize = textureSize(tex, 0);\n"
//		"	vec2 rcpFrame = vec2(1.0/texSize.x, 1.0/texSize.y);\n"
//		"// passthrough\n"
//		"//return float4( texture(tex,pos) );\n"
//		"//	return float4( FxaaPixelShader( pos, tex, rcpFrame ), 1.0f );\n"
//		"	return vec4( FxaaPixelShader( gl_FragCoord.xy*rcpFrame,\n"
//		"				FxaaFloat4(0.0f, 0.0f, 0.0f, 0.0f),		// FxaaFloat4 fxaaConsolePosPos,\n"
//		"				tex,									// FxaaTex tex,\n"
//		"				tex,									// FxaaTex fxaaConsole360TexExpBiasNegOne,\n"
//		"				tex,									// FxaaTex fxaaConsole360TexExpBiasNegTwo,\n"
//		"				rcpFrame,								// FxaaFloat2 fxaaQualityRcpFrame,\n"
//		"				FxaaFloat4(0.0f, 0.0f, 0.0f, 0.0f),		// FxaaFloat4 fxaaConsoleRcpFrameOpt,\n"
//		"				FxaaFloat4(0.0f, 0.0f, 0.0f, 0.0f),		// FxaaFloat4 fxaaConsoleRcpFrameOpt2,\n"
//		"				FxaaFloat4(0.0f, 0.0f, 0.0f, 0.0f),		// FxaaFloat4 fxaaConsole360RcpFrameOpt2,\n"
//		"				0.75f,									// FxaaFloat fxaaQualitySubpix,\n"
//		"				0.166f,									// FxaaFloat fxaaQualityEdgeThreshold,\n"
//		"				0.0833f,								// FxaaFloat fxaaQualityEdgeThresholdMin,\n"
//		"				0.0f,									// FxaaFloat fxaaConsoleEdgeSharpness,\n"
//		"				0.0f,									// FxaaFloat fxaaConsoleEdgeThreshold,\n"
//		"				0.0f,									// FxaaFloat fxaaConsoleEdgeThresholdMin,\n"
//		"				FxaaFloat4(0.0f, 0.0f, 0.0f, 0.0f)		// FxaaFloat fxaaConsole360ConstDir,\n"
//		"				) );\n"
//		"}\n"
//		"\n\n\n";
//
//	int fxaa1Quality[] = { 0, 2,	3,		4, 5 };
//	int fxaa3Quality[] = { 10, 11,	12,		15, 29 };
//
//	std::string customFilterDefinition;
//	std::string customFilterApply;
//	if ( getAntialiasingNode()->getTechnique() == vgd::node::Antialiasing::FXAA1 )
//	{
//		const int quality = vgm::clamp(getAntialiasingNode()->getQualityPreset(), 0, 4);
//
//		std::string qualityStr =	"#define FXAA_GLSL_130 1\n";
//
//		qualityStr += "  #define FXAA_PRESET " + 
//					vgd::basic::toString(fxaa1Quality[quality]) + "\n";
//
//		customFilterDefinition	= qualityStr + customFilterDefinitionFXAAv1;
//		customFilterApply		= "	color = apply( texMap2D[0], mgl_TexCoord[0].xy );\n";
//	}
//	else if ( getAntialiasingNode()->getTechnique() == vgd::node::Antialiasing::FXAA3 )
//	{
//		const int quality = vgm::clamp(getAntialiasingNode()->getQualityPreset(), 0, 4);
//
//		std::string qualityStr =	"  #define FXAA_PC 1\n"
//									"  #define FXAA_GLSL_130 1\n"
//									"  #define FXAA_GREEN_AS_LUMA 1\n";
//		qualityStr += "  #define FXAA_QUALITY__PRESET " + 
//					vgd::basic::toString(fxaa3Quality[quality]) + "\n";
//
//		customFilterDefinition	= qualityStr + customFilterDefinitionFXAAv3;
//		customFilterApply		= "	color = apply( texMap2D[0], mgl_TexCoord[0].xy );\n";
//	}
//	else
//	{
//		vgAssertN( false, "Unexpected value for technique field of vgd::node::Antialiasing" );
//	}
//
//	if ( aaPP->getCustomFilterDefinition() != customFilterDefinition )
//	{
//		aaPP->setCustomFilterDefinition( customFilterDefinition );
//	}
//
//	if ( aaPP->getCustomFilterApply() != customFilterApply )
//	{
//		aaPP->setCustomFilterApply( customFilterApply );
//	}
//}
//
//
//void Antialiasing::stageInitializeRC( vgeGLBase::technique::ForwardRendering * technique, vgeGLBase::engine::Engine * engine )
//{
//	templateStageInitializeRC<vgeGLBase::rc::Antialiasing>( technique, engine );
//}
//
//
//const bool Antialiasing::isRCUpdated( vgeGLBase::technique::ForwardRendering * technique, vgeGLBase::engine::Engine * engine, vgd::Shp< glo::IResource > genericRC )
//{
//	if ( !isEnabled() )
//	{
//		return true;
//	}
//	else
//	{
//		// Gets node dirty flag
//		vgd::field::DirtyFlag * nodeDF = getNode()->getDirtyFlag( getNode()->getDFNode() );
//		bool isRCUpdated =	nodeDF->isValid();
//		return isRCUpdated;
//	}
//}
//
//
//void Antialiasing::updateRC( vgeGLBase::technique::ForwardRendering * technique, vgeGLBase::engine::Engine * engine, vgd::Shp< glo::IResource > genericRC )
//{
//	if ( !isEnabled() ) return;
//
//	vgd::Shp< vgeGLBase::rc::Antialiasing > rc = vgd::dynamic_pointer_cast< vgeGLBase::rc::Antialiasing >( genericRC );
//	vgAssert( rc != 0 );
//
//	// color buffer
//	if ( !rc->colorBuffer )
//	{
//		stageInitializeOutputBuffersNodes( rc );
//	}
//
//	// post processing nodes
//	if ( !rc->rootPostProcessing )
//	{
//		stageInitializePostProcessing( getAntialiasingNode(), rc );
//	}
//
//	// post processing parameters
//	stageUpdatePostProcessingParameters( engine, rc );
//}
//
//
//void Antialiasing::stagePrePaint( vgeGLBase::technique::ForwardRendering * technique, vgeGLBase::engine::Engine * engine )
//{
//	if ( !isEnabled() ) return;
//
//	vgd::Shp< vgeGLBase::rc::Antialiasing > rc = getRC< vgeGLBase::rc::Antialiasing >(engine);
//	vgAssert( rc != 0 );
//
//	stageInitializeOutputBuffers( technique, engine, rc );
//}
//
//
//void Antialiasing::stageInitializeOutputBuffers( vgeGLBase::technique::ForwardRendering * technique, vgeGLBase::engine::Engine * engine, vgd::Shp< vgeGLBase::rc::Antialiasing > rc )
//{
//	using vgd::node::OutputBufferProperty;
//	using vgeGLBase::engine::GLSLState;
//
//	if ( !isEnabled() ) return;
//
//	// patches output buffers of engine
//	if ( !technique->hasOutputBufferProperties )
//	{
//		// configures current output buffers of engine
//		technique->hasOutputBufferProperties = true;
//		technique->m_outputBufferProperties->setState( 0, vgd::makeShp( new GLSLState::OutputBufferPropertyState(rc->colorBuffer.get()) ) );
//
//		engine->setCurrentPrivateOutputBuffers( 0 );
//	}
//
//	if ( !technique->isPostProcessingEnabled )
//	{
//		technique->isPostProcessingEnabled = true;
//	}
//}
//
//
//
//void Antialiasing::stagePostPaint( vgeGLBase::technique::ForwardRendering * technique, vgeGLBase::engine::Engine * engine )
//{
//	if ( !isEnabled() ) return;
//
//	vgd::Shp< vgeGLBase::rc::Antialiasing > rc = getRC< vgeGLBase::rc::Antialiasing >(engine);
//	vgAssert( rc != 0 );
//
//	const vgd::Shp< vgeGLBase::rc::FrameBufferObject > finalBuffers = technique->applyPostProcessing( engine, *technique->m_textures, &(rc->postProcessing) );
//	technique->blit( engine, finalBuffers, technique->m_fbo );
//}
//
//
//vgd::node::Antialiasing * Antialiasing::getAntialiasingNode() const
//{
//	return static_cast< vgd::node::Antialiasing * >( getNode() );
//}
//
//
//} // namespace technique
//
//} // namespace vgeGLBase
//